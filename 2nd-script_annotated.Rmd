---
title: "SGCE Interneuron"
output: html_notebook
---
# Setup
```{r message=FALSE, warning=FALSE, include=FALSE}
# Choose the correct library location for R packages installation and usage  
# diffrent paths provided depending on system setup  
# Uncomment the desired path to set library location  
# LIBLOC<-"D:/R4.2"  
# LIBLOC<-"C:/Users/Zongze Li/Documents/R/win-library/4.2"  
# LIBLOC<-"C:/Users/c1629716/AppData/Local/R/win-library/4.2"  

# Using current path for R 4.4.0 version  
LIBLOC<-"C:/Program Files/R/R-4.4.0/library"  
.libPaths(LIBLOC)  # Set library path  

# Uncomment these lines for updating packages or initializing Bioconductor  
# update.packages(LIBLOC)  
# BiocManager::install()  

# Loading necessary libraries for data procesing and visualiztion  
library(rlang, lib.loc = LIBLOC)  
library(matrixStats, lib.loc = LIBLOC)  
library(Matrix, lib.loc = LIBLOC)  
library(lifecycle, lib.loc = LIBLOC)  
library(Rcpp, lib.loc = LIBLOC)  
library(cli, lib.loc = LIBLOC)  

# Define basic packages for loading  
BASIC <- c("devtools", "BiocManager", "remotes")  

# Collection of other required packages  
PACKAGES <- c("tidyverse", "corrplot", "data.table", "Hmisc", "plyr", "dplyr",  
              "GGally", "ggnetwork", "ggplot2", "ggpubr", "ggrepel", "ggthemes",  
              "network", "openxlsx", "reshape2", "Seurat", "stringr", "tidyr",  
              "rlist", "parallel", "metap", "readr", "rliger", "ggvenn",  
              "ggdendro", "feather", "ComplexUpset", "doParallel", "igraph",  
              "treemapify", "UpSetR", "Matrix.utils", "ggforce", "cluster",  
              "factoextra", "rstatix", "car", "ggrain", "WGCNA", "hdf5r", "anndata")  

# Bioconductor packages  
BIOCMANAGER_PACKAGES <- c("scater", "scmap", "edgeR", "SingleCellExperiment",  
                          "tximeta", "tximport", "biomaRt", "DESeq2", "multtest",  
                          "scran", "scMerge", "harmony", "AUCell", "RcisTarget",  
                          "GENIE3", "PCAtools", "BiocGenerics", "DelayedArray",  
                          "DelayedMatrixStats", "limma", "S4Vectors",  
                          "SummarizedExperiment", "batchelor", "fgsea",  
                          "GO.db", "lme4", "genefilter", "HDF5Array", "terra",  
                          "ggrastr", "clusterProfiler", "org.Hs.eg.db", "EWCE",  
                          "velociraptor", "pcaMethods", "MAST", "WGCNA", "igraph",  
                          "GeneOverlap", "ggrepel", "UCell", "rrvgo")  

# GitHub sourced packages  
GITHUB_PACKAGES <- c("cvarrichio/Matrix.utils", "cole-trapnell-lab/leidenbase",  
                     "satijalab/seurat-wrappers", "cole-trapnell-lab/monocle3",  
                     "aertslab/SCopeLoomR", "aertslab/SCENIC", "davidsjoberg/ggsankey",  
                     "neurogenomics/MAGMA_Celltyping", "velocyto-team/velocyto.R",  
                     "ricardo-bion/ggradar", "NightingaleHealth/ggforestplot",  
                     "smorabit/hdWGCNA", "immunogenomics/presto",  
                     "mojaveazure/seurat-disk")  

# GitHub packages for loading  
GITHUB_PACKAGES_LOAD <- c("leidenbase", "SeuratWrappers", "monocle3",  
                          "SCopeLoomR", "SCENIC", "ggsankey", "MAGMA.Celltyping",  
                          "velocyto.R", "ggforestplot", "hdWGCNA", "presto",  
                          "ggradar", "SeuratDisk")  

# Install and load BASIC packages if not present  
for (x in BASIC) {  
  if (!require(x, lib.loc=LIBLOC, character.only=TRUE)) {  
    install.packages(x, lib=LIBLOC)  
    library(x, lib.loc=LIBLOC, character.only=TRUE)  
  }  
}  

# Install and load additional PACKAGES if missing  
for (x in PACKAGES) {  
  if (!require(x, lib.loc=LIBLOC, character.only=TRUE)) {  
    install.packages(x, lib=LIBLOC)  
    library(x, lib.loc=LIBLOC, character.only=TRUE)  
  }  
}  

# Install Bioconductor packages and load them  
for (x in BIOCMANAGER_PACKAGES) {  
  if (!require(x, lib.loc=LIBLOC, character.only=TRUE)) {  
    BiocManager::install(x, lib=LIBLOC)  
    library(x, lib.loc=LIBLOC, character.only=TRUE)  
  }  
}  

# Install GitHub packages (commented section for manual installation)  
# tryCatch({for (x in GITHUB_PACKAGES) {remotes::install_github(x)}}, error=function(e){})  

# Load GitHub packages already installed  
for (x in GITHUB_PACKAGES_LOAD) {  
  require(x, lib.loc=LIBLOC, character.only=TRUE)  
}  

# Clean environment by removing temporary variables  
rm(BASIC, PACKAGES, BIOCMANAGER_PACKAGES, GITHUB_PACKAGES, GITHUB_PACKAGES_LOAD, x)  

# Define color palette for plotting  
colour_palette <- c(ggthemes_data$tableau$`color-palettes`$regular$`Tableau 20`$value,  
                    "#CA0AFF", "#10DFDF", ggthemes_data$tableau$`color-palettes`$regular$`Color Blind`$value,  
                    ggthemes_data$excel$classic$fill, ggthemes_data$calc$colors$value)  

# Correct OneDrive path to project-specific directory  
Sys.setenv("ONEDRIVE" = str_replace(Sys.getenv("ONEDRIVE"), "The Open", "Cardiff"))  

# Directory paths for project workflow  
PROJECT_DIR <- paste0(Sys.getenv("OneDrive"), "/Postdoc/Project/RNAseq/SGCE scRNAseq")  
COUNT_INPUTDIR <- paste0(PROJECT_DIR, "/Raw count")  
ANALYSIS_OUTPUTDIR <- paste0(PROJECT_DIR, "/2nd PT2NoAraC")  
FIGURE_OUTPUTDIR <- paste0(ANALYSIS_OUTPUTDIR, "/Figures")  
SAVE_DIR <- paste0(ANALYSIS_OUTPUTDIR, "/Saved RData")  

# Create directories if they don't exist  
if (!dir.exists(ANALYSIS_OUTPUTDIR)) dir.create(ANALYSIS_OUTPUTDIR)  
if (!dir.exists(FIGURE_OUTPUTDIR)) dir.create(FIGURE_OUTPUTDIR)  
if (!dir.exists(SAVE_DIR)) dir.create(SAVE_DIR)  

# Load gene information from a CSV file  
gene_info <- fread(file=paste0(PROJECT_DIR, "/gene_info.csv"), data.table=FALSE)  

# Format gene identifiers  
gene_info$Gene_ID <- paste(str_split(gene_info$Gene_ID, "_", simplify=TRUE)[,2],  
                           str_split(gene_info$Gene_ID, "_", simplify=TRUE)[,1],  
                           sep="-")  

# Load sample metadata from Excel  
sample_metadata <- read.xlsx(xlsxFile=paste0(PROJECT_DIR, "/SampleMetadata.xlsx"))  

# Define selected marker genes with lineage information  
temp_feature <- data.frame(Gene=c("CD44", "ATF3", "S100B", "GFAP", "SOX9", "HES1", "VIM",  
                                  "EGFR", "NFIA", "NFIB", "NFIX", "AQP4", "SLC1A2",  
                                  "SLC1A3", "GJA1", "GJB6", "S100A16", "S100A13",  
                                  "ASCL1", "NEUROG1", "NEUROG2", "NEUROD1", "NEUROD2",  
                                  "NEUROD4", "NEUROD6", "RBFOX3", "SNAP25", "STMN2",  
                                  "SYT1", "TUBB2B", "TUBB3", "DCX", "SOX11", "AIF1",  
                                  "C1QC", "CD83", "CSF1R", "A2M", "APOLD1", "CLDN5",  
                                  "FN1", "TBR1", "TBR2", "BCL11B", "CUX1", "SATB2",  
                                  "EMX1", "EMX2", "SLC17A7", "SLC17A6", "NKX2-1",  
                                  "LHX6", "LHX8", "SOX6", "OLIG2", "ARX", "MAFB",  
                                  "ERBB4", "DLX2", "DLX5", "NR2F1", "GSX2", "DLX1",  
                                  "DLX6-AS1", "MEF2C", "NR2F2", "PROX1", "SP8",  
                                  "SCGN", "CALB2", "VIP", "HTR3A", "CCK", "LAMP5",  
                                  "BCL11B", "NOLZ1", "FOXP1", "FOXP2", "ISL1",  
                                  "PPP1R1B", "DRD1", "MEIS2", "EBF1", "PCP4", "GAD1",  
                                  "GAD2", "RELN", "SST", "PVALB", "VIP", "HTR3A",  
                                  "TAC1", "CCK", "CR", "NPY", "CALB2", "SLC32A1",  
                                  "ERBB4", "NXPH1", "LMX1A", "LMX1B", "FOXA1",  
                                  "FOXA2", "OTX2", "DMRTA2", "NR4A2", "PITX3",  
                                  "SOX2", "SOX1", "SOX3"))

```
## Functions
### Function-Gene name
```{r}
# Define a function to get gene ID by gene name  
FUN_gene <- function(gene) {  
  # Subset rows from gene_info where gene name match input  
  subset(gene_info, Gene_Name %in% gene)$Gene_ID  
}  

# Define a function to get gene name by gene ID  
FUN_geneid <- function(geneid) {  
  # Subset rows from gene_info where gene ID match input  
  subset(gene_info, Gene_ID %in% geneid)$Gene_Name  
}  

```

### Function-Seurat_clustering
```{r}
# Define a function for clustering Seurat object and saving plots  
FUN_seurat_clustering <- function(seurat, prefix, reduction) {  

  # Check if directory for saving plots exist, create it if missing  
  if (!dir.exists(paste0(FIGURE_OUTPUTDIR, "/", prefix)))  
    dir.create(paste0(FIGURE_OUTPUTDIR, "/", prefix))  

  # Apply clustering over resolutions ranging from 0.1 to 2.0  
  lapply(seq(1, 20) / 10, FUN = function(x) {  
      
    # Print message showing current clustering resolution  
    print(paste("Finding clusters res=", x, sep = " "))  

    # Perform clustering at resolution x  
    seurat <- FindClusters(seurat, verbose = FALSE, res = x)  

    # Generate dimensionality reduction plot with clustering labels  
    p <- DimPlot(seurat, label = TRUE, reduction = reduction, pt.size = 0.5) +  
         scale_colour_manual(values = colour_palette) +  
         ggtitle(paste0("res=", x)) +  
         theme(text = element_text(size = 12)) +  
         guides(fill = guide_legend(ncol = 2))  

    # Save plot as a TIFF file with resolution-specific filename  
    ggsave(plot = p, filename = paste0(FIGURE_OUTPUTDIR, "/", prefix, "/res", x, ".tiff"),  
           width = 12, height = 10, units = "cm", dpi = 600, device = "tiff", limitsize = TRUE)  
    
    # Return Seurat object (but note: lapply discards returned results here)  
    seurat  
  })  
}  

```

### Function-Marker_expression_umap

```{r}
# Define a function to visualize marker expression using UMAP in Seurat  
FUN_marker_expression_umap_seurat <- function(seurat, marker, reduction) {  

  # Loop over unique cell classes in marker using sapply  
  sapply(levels(factor(marker$CellClass)), FUN = function(x) {  
    
    # Select genes specific to the current cell class  
    temp <- marker$gene[marker$CellClass == x]  
    
    # Filter genes that are present in Seurat object  
    temp <- temp[temp %in% rownames(seurat)]  
    
    # Create a feature plot for marker expression visualization  
    p <- FeaturePlot(seurat, features = unique(temp), pt.size = 0.05, ncol = 5,  
                     order = TRUE, cols = c("lightgrey", "red"), reduction = reduction,  
                     repel = TRUE) +  
         theme(text = element_text(size = 4), title = element_text(size = 4),  
               legend.position = "none")  
    
    # Save the plot as a TIFF file with cell class-specific filename  
    ggsave(plot = p, filename = paste0(FIGURE_OUTPUTDIR, "/Marker expression on ",  
                                       reduction, "/", x, ".tiff"),  
           width = 40, height = ceiling(length(temp) / 5) * 5,  
           units = "cm", dpi = 300, device = "tiff", limitsize = FALSE)  
  })  
}  

```

### Function-DEG comparison
```{r}
# Define a function for DEG comparison (Differential Expression Gene analysis)  
FUN_DEG_comparison <- function(query, prefix, ident.var = "seurat_clusters", comparison = NULL, assay = "RNA", slot = "data", logFC = 0.25, test.use = "wilcox", latent.vars = NULL) {  

  ## This script will produce a list containing a data.frame of the DEG list and a data.frame of the GO enrichment results.  
  
  # parameter description
  # query: a seurat object after dimension reduction and clustering
  # ident.var: the variable containing the Idents information
  # (Optional) comparison: a data.frame containing two columns to describe which pair of clusters to be compared against each other during FindMarkers. Only specify if pair-wise DEG analysis (FindMarkers) is intended.
  # prefix: name of your comparison. This will be used as the name of folders containing your results.  
  
  # Error handling - parameter input  

  if (class(query)[1] != "Seurat") {  
    print("The query is not a Seurat object.")  
    break  
  }  

  if (is.null(ident.var)) {  
    print(paste0("WARNING: No ident.var specified. Default of the seurat object will be used"))  
  }  

  if (!is.null(ident.var) & !ident.var %in% names(query@meta.data)) {  
    print("The ident.var is not found in the query Seurat object.")  
    break  
  }  

  if (!is.null(comparison)) {  
    if ((ncol(comparison) != 2 | class(comparison) != "data.frame")) {  
      print("The comparison table is not a data.frame or the number of columns does not equal to 2.")  
      break  
    }  
  }  

  # Setup directory for saving results  
  if (is.null(ANALYSIS_OUTPUTDIR)) {  
    ANALYSIS_OUTPUTDIR <- getwd()  
    print("No specified analysis directory. Data will be stored at the current working directory:")  
    print(ANALYSIS_OUTPUTDIR)  
  }  

  if (!dir.exists(paste0(ANALYSIS_OUTPUTDIR, "/DEG")))  
    dir.create(paste0(ANALYSIS_OUTPUTDIR, "/DEG"))  

  # Pre-processing query  
  DefaultAssay(query) <- assay  

  if (!is.null(ident.var)) {  
    Idents(query) <- ident.var  
  }  

  if (is.null(comparison)) {  
    # Perform FindAllMarkers (for all clusters)  
    DEG_dframe <- FindAllMarkers(query, assay = assay, slot = slot, only.pos = TRUE, min.pct = 0.25, logfc.threshold = logFC, test.use = test.use, latent.vars = latent.vars)  
    DEG_dframe$Comparison <- paste0(DEG_dframe$cluster, "_vs_others")  
    DEG_dframe$pctratio <- DEG_dframe$pct.1 / DEG_dframe$pct.2  
  } else {  
    # Perform pair-wise comparison (FindMarkers)  
    DEG_dframe <- as.data.frame(rbindlist(lapply(1:nrow(comparison), FUN = function(n) {  
      ident1 = comparison[n, 1]  
      ident2 = comparison[n, 2]  
      print(paste0("Comparing #", n, ": ", ident1, " and ", ident2))  
      temp <- FindMarkers(query, ident.1 = ident1, ident.2 = ident2, test.use = test.use, min.pct = 0.25, logfc.threshold = logFC, only.pos = TRUE, latent.vars = latent.vars)  
      temp$gene <- rownames(temp)  
      temp$cluster <- paste(ident1, ident2, sep = "_vs_")  
      temp$pctratio <- temp$pct.1 / temp$pct.2  
      temp  
    }), use.names = TRUE))  
  }  

  # Export DEG list to Excel file  
  write.xlsx(DEG_dframe, file = paste0(ANALYSIS_OUTPUTDIR, "/DEG/DEG_", prefix, ".xlsx"))  

  # Return a list of DEG results  
  return(DEG_dframe)  
}  

```

### Function-Seurat Reference Mapping

```{r}
# Define a function for Seurat reference mapping (transfer of labels from reference dataset to query dataset)  
FUN_seurat_reference_mapping <- function(query, reference, prefix, IdentVariable = "seurat_clusters", k.weight = 50, mapped.query = NULL, plot.only = FALSE, dims = 1:50, reference.exclusion = NULL, reference.assay = NULL, query.assay = NULL, reference.reduction = NULL) {  
  # Set the default assay for the query dataset
  DefaultAssay(query) <- query.assay  

  if (!plot.only) {  
    # Optionally, find variable features for query (commented out in this script)  
    # query <- FindVariableFeatures(query, selection.method = "vst", nfeatures = 2000)  

    # Print which clusters to exclude from the reference dataset  
    print(paste("Excluding the following clusters in reference -", IdentVariable, ": ", reference.exclusion))  

    # Exclude specific clusters from the reference  
    reference <- reference[, !reference@meta.data[, IdentVariable] %in% reference.exclusion]  
    reference <- FindVariableFeatures(reference, selection.method = "vst", nfeatures = 2000)  

    # Set the identity of the reference object based on the IdentVariable  
    Idents(reference) <- reference@meta.data[, IdentVariable]  

    # Handling for possible dimensionality reduction methods in the reference  
    if (!is.null(reference.reduction)) {  
      if (reference.reduction == "harmony") {  
        print("Using harmony from the reference")  
        reference[['harmony2']] <- CreateDimReducObject(embeddings = reference[['harmony']]@cell.embeddings[, dims], key = "harmony2_", loadings = reference[['pca']]@feature.loadings[, dims], assay = "RNA")  
        reference.reduction <- "harmony2"  
      }  
    }  

    # Find anchors between reference and query datasets  
    query.anchor <- FindTransferAnchors(reference = reference, query = query, dims = dims, reference.assay = reference.assay, query.assay = query.assay, reference.reduction = reference.reduction)  

    # Transfer labels from reference to query using the found anchors  
    prediction <- TransferData(anchorset = query.anchor, refdata = Idents(reference), dims = dims, k.weight = k.weight)  

    # Add the prediction results as metadata to the query dataset  
    prediction.query <- AddMetaData(query, metadata = prediction)  
  } else {  
    # If only plotting, use provided mapped query  
    prediction.query <- mapped.query  
  }  

  # Create a violin plot for predicted class vs. prediction score  
  p <- prediction.query@meta.data %>%  
    ggplot(aes(x = predicted.id, y = prediction.score.max)) +  
    geom_violin(aes(fill = predicted.id)) +  
    geom_hline(yintercept = 0.5) +  
    scale_fill_tableau() +  
    facet_wrap(. ~ seurat_clusters, scales = "free_x", ncol = 3) +  
    theme_bw() +  
    theme(legend.position = "bottom",  
          axis.text.x = element_text(angle = 45, vjust = 1, hjust = 1)) +  
    labs(x = "seurat_clusters", fill = "predicted.id")  

  # Save the violin plot as a tiff file  
  ggsave(plot = p, filename = paste0(prefix, "/Prediction score.tiff"), height = 5 * length(unique(prediction.query$seurat_clusters)) / 3 + 5, width = 10, units = "cm", dpi = 600, device = "tiff", limitsize = FALSE)  

  # Create a heatmap for prediction percentages per cluster  
  p <- prediction.query@meta.data %>%  
    group_by(seurat_clusters, predicted.id) %>% summarise(N = n()) %>%  
    inner_join(y = prediction.query@meta.data %>% group_by(seurat_clusters) %>% summarise(Num = n()), by = "seurat_clusters") %>%  
    ggplot(aes(x = predicted.id, y = seurat_clusters, fill = N / Num * 100)) +  
    geom_tile(colour = "black") +  
    scale_fill_gradient(low = "grey", high = "red") +  
    theme_bw() +  
    labs(x = "predicted.id", y = "seurat_clusters", fill = "Percent of\ncells (%)") +  
    theme(legend.position = "bottom",  
          axis.text.x = element_text(angle = 45, vjust = 1, hjust = 1, size = 8))  

  # Save the heatmap as a tiff file  
  ggsave(plot = p, filename = paste0(prefix, "/Prediction heatmap.tiff"), height = length(unique(prediction.query$seurat_clusters)) * 1 + 5, width = length(unique(prediction.query$predicted.id)) + 2, units = "cm", dpi = 600, device = "tiff", limitsize = FALSE)  

  # Return the prediction query with metadata  
  return(prediction.query)  
}  

```



### Function - Query common gene modules
```{r}
# Define a function for performing gene-based or module-based analysis and GO enrichment analysis  
FUN_gene_query_upset <- function(data, gene = NULL, module = NULL, export.dir = paste0(ANALYSIS_OUTPUTDIR, "/Monocle/Shared_DEG"), background = 23018, reference.dataset = NULL, nGO = 10, do.GO = TRUE) {  
  # Load the hypeR package for hypergeometric enrichment analysis  
  library(hypeR)  

  # Check if neither gene nor module is provided  
  if (is.null(gene) & is.null(module)) {  
    print("No criterion used.")  
    break  # Stop execution if no input criterion is given  
  }  

  # Create a directory for raw GO enrichment data if it does not exist  
  if (!dir.exists(paste0(export.dir, "/raw_GO"))) {  
    dir.create(paste0(export.dir, "/raw_GO"), recursive = TRUE)  
  }  

  # If module is provided but not gene, run module-based analysis  
  if (is.null(gene) & !is.null(module)) {  
    print("Module mode. Specified modules contain these genes:")  
    matching_row_index <- which(apply(data, 1, function(row) {  
      all(row == names(data) %in% module)  
    }))  

    if (is.na(matching_row_index[1])) {  
      print("No overlapping genes.")  
      break  # Stop execution if no matching genes found  
    }  

    # Get the matched genes and merge with gene match list  
    matched_genes <- rownames(data)[matching_row_index]  
    matched_genes_df <- inner_join(x = data.frame(hgnc_symbol = matched_genes),  
                                   y = gene_match_list,  
                                   by = "hgnc_symbol")  
    print(matched_genes)  
    write.xlsx(matched_genes_df, file = paste0(export.dir, "/", str_flatten(module, " "), ".xlsx"))  

  } else {  
    # If gene is provided but not module, run gene-based analysis  
    if (!is.null(gene) & is.null(module)) {  
      print("Gene mode. These genes are found in the following modules:")  
      matched_genes <- gene  
      module <- "Custom"  
      print(colnames(data)[which(data[gene,] == TRUE)])  # Print modules containing the gene  

    } else {  
      # If both gene and module are specified, print error and break  
      if (!is.null(gene) & !is.null(module)) {  
        print("Gene and module can't be specified at the same time.")  
        break  
      }  
    }  
  }  

  # Return matched genes for further use  
  return(matched_genes)  

  # If GO enrichment is enabled, proceed with the GO enrichment analysis  
  if (do.GO) {  
    # Perform enrichment analysis using hypeR package  
    DEG_GOenrichment <- as.data.frame(rbindlist(lapply(1:length(reference.dataset), FUN = function(m) {  
      print(paste0("Enrichment analyses using ", names(reference.dataset)[m]))  
      if (length(matched_genes) > 0) {  
        temp <- hypeR(matched_genes, reference.dataset[[m]], test = "hypergeometric", background = background, fdr = 0.05)  
        hyp_to_excel(temp, file_path = paste0(export.dir, "/raw_GO/", str_flatten(module, " "), "_GO enrichment_", names(reference.dataset)[m], ".xlsx"))  
        enrichment <- read.xlsx(xlsxFile = paste0(export.dir, "/raw_GO/", str_flatten(module, " "), "_GO enrichment_", names(reference.dataset)[m], ".xlsx"), sheet = 1)  
        if (nrow(enrichment) > 0) {  
          enrichment$modules <- str_flatten(module, " ")  
          enrichment$pct_overlap <- (enrichment$overlap * enrichment$background) / (enrichment$signature * enrichment$geneset)  
          enrichment$genesets <- names(reference.dataset)[m]  
        }  
      }  
      enrichment$label <- tolower(enrichment$label)  
      enrichment <- left_join(enrichment, goterms, by = "label")  

      return(enrichment)  
    }), use.names = TRUE, fill = TRUE))  

    # Save the GO enrichment results to an Excel file  
    write.xlsx(DEG_GOenrichment, file = paste0(export.dir, "/", str_flatten(module, " "), "_GO enrichment.xlsx"))  

    # Prepare the data for plotting the top enriched GO terms  
    DEG_GOenrichment_top <- as.data.frame(rbindlist(lapply(levels(factor(DEG_GOenrichment$genesets)), FUN = function(x) {  
      as.data.frame(rbindlist(lapply(levels(factor(DEG_GOenrichment$modules)), FUN = function(y) {  
        temp <- subset(DEG_GOenrichment, fdr < 0.05 & genesets == x & modules == y & geneset > 10)  
        temp <- top_n(temp, nGO, -fdr)  
      }), use.names = TRUE))  
    }), use.names = TRUE))  

    # Plotting GO enrichment results  
    sapply(levels(factor(DEG_GOenrichment_top$modules)), FUN = function(x) {  
      sapply(levels(factor(DEG_GOenrichment_top$genesets)), FUN = function(y) {  
        temp <- subset(DEG_GOenrichment_top, modules == x & genesets == y)  
        width.unit <- max(nchar(temp$label))  
        if (is.infinite(width.unit)) width.unit = 0  
        p <- ggplot(data = temp,  
                    aes(x = -log10(fdr), y = reorder(label, -fdr), fill = (pct_overlap), size = -log10(fdr))) +  
          geom_point(colour = "black", pch = 21) +  
          scale_fill_gradient(limits = c(NA, 100), low = "white", high = "red", na.value = "red", trans = "log10") +  
          theme_bw() +  
          theme(axis.text.y = element_text(size = 11)) +  
          labs(x = "-log10FDR", y = "GO term", size = "-log10FDR", fill = "Enrichment", title = x, subtitle = y)  
        ggsave(plot = p, filename = paste0(export.dir, "/Figures/GO enrichment_modules ", x, "_", y, ".tiff"),  
               width = width.unit * 0.2 + 5, height = (length(levels(factor(temp$label))) * 0.5 + 5), units = "cm", dpi = 600, device = "tiff", limitsize = TRUE)  
      })  
    })  
  }  

  # Return matched genes for further analysis  
  return(matched_genes)  
}  

```


### Function - GO enrichment

```{r}
# Define the function to perform geneset overlap analysis and GO enrichment
FUN_Geneset_Overlap <- function(query, universe, OrgDb = org.Hs.eg.db, ont = "All", keyType = "SYMBOL", minGSSize = 50, maxGSSize = 500, prefix = NULL, nGO = 10, pAdjustMethod = "BH", pvalueCutoff = 0.01, qvalueCutoff = 0.05, pthreshold = 0.05) {  
  # Create output directory for storing results if prefix is provided  
  if (!is.null(prefix)) {  
    output_dir <- paste0(ANALYSIS_OUTPUTDIR, "/Geneset Enrichment")  
    if (!dir.exists(output_dir))  
      dir.create(output_dir)  
  }  
  # Load the org.Hs.eg.db package for gene annotations  
  require(org.Hs.eg.db)  
  
  # Perform GO enrichment for each gene set in the query  
  DEG_GO_BP2 <- lapply(1:length(query), FUN = function(i) {  
    temp <- as.data.table(enrichGO(gene = query[[i]], universe = universe, OrgDb = OrgDb, ont = ont, pAdjustMethod = pAdjustMethod, pvalueCutoff = pvalueCutoff, qvalueCutoff = qvalueCutoff, readable = TRUE, keyType = keyType, pool = TRUE, minGSSize = minGSSize, maxGSSize = maxGSSize)@result)  
    temp$Cluster <- names(query)[i]  
    return(temp)  
  }) %>% rbindlist(use.names = TRUE)  
  
  # Calculate the enrichment score for each GO term  
  DEG_GO_BP2$EnrichmentScore <- ((as.numeric(str_split(DEG_GO_BP2$GeneRatio, fixed("/"), simplify = TRUE)[, 1])) / (as.numeric(str_split(DEG_GO_BP2$GeneRatio, fixed("/"), simplify = TRUE)[, 2]))) / ((as.numeric(str_split(DEG_GO_BP2$BgRatio, fixed("/"), simplify = TRUE)[, 1])) / (as.numeric(str_split(DEG_GO_BP2$BgRatio, fixed("/"), simplify = TRUE)[, 2])))  
  
  # Write the results to an Excel file  
  write.xlsx(DEG_GO_BP2, file = paste0(output_dir, "/", prefix, "_GO.xlsx"))  
  
  # Prepare and plot top GO terms based on p-adjusted values  
  if (!is.null(nGO)) {  
    # Filter and get top nGO GO terms for each cluster  
    DEG_GOenrichment_top <- as.data.frame(rbindlist(lapply(levels(factor(DEG_GO_BP2$Cluster)), FUN = function(y) {  
      temp <- subset(DEG_GO_BP2, p.adjust < pthreshold & Cluster == y)  
      temp <- top_n(temp, nGO, -p.adjust)  
    }), use.names = TRUE))  
    
    # Plotting for each cluster and GO term  
    sapply(levels(factor(DEG_GOenrichment_top$Cluster)), FUN = function(x) {  
      temp <- subset(DEG_GOenrichment_top, Cluster == x & ONTOLOGY == "BP")  
      width.unit <- max(nchar(temp$Description))  
      if (is.infinite(width.unit)) width.unit = 0  
      
      # Create the GO enrichment plot  
      p <- ggplot(data = temp,  
                  aes(x = -log10(p.adjust), y = reorder(Description, -p.adjust),  
                      fill = (Count), size = -log10(p.adjust))) +  
        geom_point(colour = "black", pch = 21) +  
        scale_fill_gradient(low = "grey", high = "red", na.value = "red") +  
        theme_bw() +  
        theme(axis.text.y = element_text(size = 11)) +  
        labs(x = "-log10 p.adjust", y = "GO term", size = "-log10 p.adjust", fill = "Number\nof hits", title = x)  
      
      # Save the plot to a TIFF file  
      ggsave(plot = p, filename = paste0(output_dir, "/Figures/", prefix, "/GO_ ", x, ".tiff"),  
             width = width.unit * 0.2 + 5, height = (length(levels(factor(temp$label))) * 1 + 5), units = "cm", dpi = 600, device = "tiff", limitsize = TRUE)  
    })  
  }  
  
  # Return the GO enrichment data  
  return(DEG_GO_BP2)  
}  

```

### Function - ReduceGO
```{r}
# Define the function to reduce GO terms based on semantic similarity
FUN_ReduceGO <- function(go, orgdb = "org.Hs.eg.db", ont = "BP", method = "Rel", threshold = 0.5) {
  # Calculate the semantic similarity matrix for GO terms
  simMatrix <- calculateSimMatrix(go$ID, orgdb = orgdb, ont = ont, method = method)
  
  # Assign a score to each GO term based on the negative log-transformed q-value
  scores <- setNames(-log10(go$qvalue), go$ID)
  
  # Reduce the GO terms based on the similarity matrix and specified threshold
  reducedTerms <- reduceSimMatrix(simMatrix = simMatrix, scores = scores, threshold = threshold, orgdb = orgdb)
  
  # Return a list containing the reduced GO terms and the similarity matrix
  return(list(reducedTerms = reducedTerms, simMatrix = simMatrix))
}

```

### Function - General_Geneset_Overlap

```{r}
# Define the function for Geneset overlap analysis with enrichment testing
FUN_Geneset_Overlap_General <- function(query, reference, universe, minGSSize = 10, maxGSSize = 1000, 
                                         prefix = NULL, nGO = 10, pAdjustMethod = "BH", pvalueCutoff = 0.01, 
                                         qvalueCutoff = 0.05, pthreshold = 0.05) {
  
  # Create output directory if not provided
  if (!is.null(prefix)) {
    output_dir <- paste0(ANALYSIS_OUTPUTDIR, "/Geneset Enrichment")
    if (!dir.exists(output_dir)) dir.create(output_dir)
  }
  
  # Prepare reference data frame with cell names and gene IDs
  reference_df <- lapply(1:length(reference), FUN = function(i) {
    temp <- data.frame(geneID = reference[[i]])
    temp$cellName <- names(reference)[i]
    return(temp)
  }) %>% rbindlist() %>% as.data.frame()
  
  reference_df <- reference_df[, c("cellName", "geneID")]
  
  # Perform enrichment analysis for each cluster in query
  DEG_GO_BP2 <- lapply(1:length(query), FUN = function(i) {
    temp <- enricher(gene = query[[i]], TERM2GENE = reference_df, universe = universe,
                     pAdjustMethod = pAdjustMethod, pvalueCutoff = pvalueCutoff, 
                     qvalueCutoff = qvalueCutoff, minGSSize = minGSSize, 
                     maxGSSize = maxGSSize)@result
    temp$Cluster <- names(query)[i]
    return(temp)
  }) %>% rbindlist(use.names = TRUE)
  
  # Compute enrichment scores for each term
  DEG_GO_BP2$EnrichmentScore <- ((as.numeric(str_split(DEG_GO_BP2$GeneRatio, fixed("/"), simplify = TRUE)[, 1])) / 
                                 (as.numeric(str_split(DEG_GO_BP2$GeneRatio, fixed("/"), simplify = TRUE)[, 2]))) / 
                                 ((as.numeric(str_split(DEG_GO_BP2$BgRatio, fixed("/"), simplify = TRUE)[, 1])) / 
                                 (as.numeric(str_split(DEG_GO_BP2$BgRatio, fixed("/"), simplify = TRUE)[, 2])))
  
  # Save results to an Excel file
  write.xlsx(DEG_GO_BP2, file = paste0(output_dir, "/", prefix, "_GO.xlsx"))
  
  # If nGO is specified, select top GO terms for each cluster for plotting
  if (!is.null(nGO)) {
    # Prepare top enrichment data for plotting
    DEG_GOenrichment_top <- as.data.frame(rbindlist(lapply(levels(factor(DEG_GO_BP2$Cluster)), FUN = function(y) {
      temp <- subset(DEG_GO_BP2, p.adjust < pthreshold & Cluster == y)
      temp <- top_n(temp, nGO, -p.adjust)
    }), use.names = TRUE))
    
    # Plot the enrichment results
    sapply(levels(factor(DEG_GOenrichment_top$Cluster)), FUN = function(x) {
      temp <- subset(DEG_GOenrichment_top, Cluster == x)
      width.unit <- max(nchar(temp$Description))
      if (is.infinite(width.unit)) width.unit = 0
      p <- ggplot(data = temp, aes(x = -log10(p.adjust), y = reorder(Description, -p.adjust),
                                  fill = (Count), size = -log10(p.adjust))) +
        geom_point(colour = "black", pch = 21) +
        scale_fill_gradient(low = "grey", high = "red", na.value = "red") +
        theme_bw() +
        theme(axis.text.y = element_text(size = 11)) +
        labs(x = "-log10 p.adjust", y = "Geneset", size = "-log10 p.adjust", fill = "Number\nof hits", title = x)
      
      ggsave(plot = p, filename = paste0(output_dir, "/Figures/", prefix, "/GO_", x, ".tiff"),
             width = width.unit * 0.2 + 5, height = (length(levels(factor(temp$label))) * 0.5 + 5), 
             units = "cm", dpi = 600, device = "tiff", limitsize = TRUE)
    })
  }
  
  # Return the results of the enrichment analysis
  return(DEG_GO_BP2)
}

```

### Function - GO overlap score
```{r}
FUN_GO_overlap_score <- function(minimum, term_metadata, GO_db, id_var = "ID", measure = "Wang") {
  library(GOSemSim)
  
  # Check if the terms in 'minimum' exist in the GO list (term_metadata)
  if (sum(minimum %in% term_metadata[, id_var]) == 0) {
    print("Minimum terms not in the GO list")
    break
  }
  
  # Filter the term metadata to keep terms with p.adjust < 0.05
  term_metadata <- subset(term_metadata, p.adjust < 0.05)
  
  # Split the gene IDs in each term and create a list of gene IDs per term
  term_hit <- lapply(1:nrow(term_metadata), FUN = function(i) {
    unlist(str_split(term_metadata$geneID[i], pattern = fixed("/"), simplify = FALSE))
  })
  names(term_hit) <- term_metadata$ID
  
  # Extract the genes for the minimum terms
  minimum_genes <- unlist(term_hit[names(term_hit) %in% minimum])
  
  # Calculate overlap between the minimum genes and genes in each term
  overlap <- sapply(term_hit, FUN = function(y) {
    sum(y %in% minimum_genes)
  }) / sapply(term_hit, length)  # Normalize overlap by total genes in each term
  
  # Calculate the semantic similarity between terms in the GO database using the specified measure
  similarity <- rowMax(mgoSim(names(term_hit), minimum, semData = GO_db, measure = measure, combine = NULL))
  
  # Store overlap and similarity results in the term metadata
  term_metadata$pct_overlap_minirep <- overlap
  term_metadata$max_similarity_minirep <- similarity
  
  return(term_metadata)
}

```



### Function - Minimal GO representation
```{r}
FUN_GO_overlap_score <- function(minimum, term_metadata, GO_db, id_var = "ID", measure = "Wang") {
  library(GOSemSim)
  
  # Check if the terms in 'minimum' exist in the GO list (term_metadata)
  if (sum(minimum %in% term_metadata[, id_var]) == 0) {
    print("Minimum terms not in the GO list")
    break
  }
  
  # Filter the term metadata to keep terms with p.adjust < 0.05
  term_metadata <- subset(term_metadata, p.adjust < 0.05)
  
  # Split the gene IDs in each term and create a list of gene IDs per term
  term_hit <- lapply(1:nrow(term_metadata), FUN = function(i) {
    unlist(str_split(term_metadata$geneID[i], pattern = fixed("/"), simplify = FALSE))
  })
  names(term_hit) <- term_metadata$ID
  
  # Extract the genes for the minimum terms
  minimum_genes <- unlist(term_hit[names(term_hit) %in% minimum])
  
  # Calculate overlap between the minimum genes and genes in each term
  overlap <- sapply(term_hit, FUN = function(y) {
    sum(y %in% minimum_genes)
  }) / sapply(term_hit, length)  # Normalize overlap by total genes in each term
  
  # Calculate the semantic similarity between terms in the GO database using the specified measure
  similarity <- rowMax(mgoSim(names(term_hit), minimum, semData = GO_db, measure = measure, combine = NULL))
  
  # Store overlap and similarity results in the term metadata
  term_metadata$pct_overlap_minirep <- overlap
  term_metadata$max_similarity_minirep <- similarity
  
  return(term_metadata)
}

```

### Function - candidate expression testing
```{r}
FUN_candidate_expression_testing <- function(markers, seurat, prefix, ident.var, ident.1 = NULL, ident.2 = NULL, numCores = (detectCores() - 1)) {
  # Initialize parallel computation
  cl <- makeCluster(numCores)
  clusterExport(cl, c("markers", "seurat", "prefix", "ident.var", "ident.1", "ident.2"), envir = environment())
  clusterEvalQ(cl, require(Seurat))
  clusterEvalQ(cl, require(rlist))
  clusterEvalQ(cl, require(stringr))
  clusterEvalQ(cl, require(data.table))
  
  # Parallel processing of markers
  candidate_markers_FC <- parLapply(cl, markers, fun = function(x) {
    if (x %in% rownames(seurat)) {
      seurat_temp <- seurat
      Idents(seurat_temp) <- seurat@meta.data[, ident.var]  # Set identities for comparison

      # Case when no specific groups (ident.1, ident.2) are provided
      if (is.null(ident.1) & is.null(ident.2)) {
        temp1 <- list.cbind(lapply(unique(seurat@meta.data[, ident.var]), FUN = function(y) {
          # Calculate fold change for each group
          temp <- FoldChange(seurat_temp, features = x, ident.1 = y, ident.2 = NULL, slot = "data")
          names(temp)[1] <- "FC"
          
          # Extract expression values for each group
          value.group1 <- as.numeric(GetAssayData(seurat_temp[, seurat_temp@meta.data[, ident.var] == y])[x, ])
          value.group2 <- as.numeric(GetAssayData(seurat_temp[, seurat_temp@meta.data[, ident.var] != y])[x, ])
          
          # Calculate p-value and adjust it using the Bonferroni method
          if (mean(value.group1, na.rm = TRUE) * mean(value.group2, na.rm = TRUE) > 0) {
            temp$p.adj = p.adjust(p = wilcox.test(x = value.group1, y = value.group2)$p.value, method = "bonferroni", n = nrow(seurat))
          }
          
          # Name the columns with the prefix and the group name
          names(temp) <- paste(names(temp), prefix, y, sep = "_")
          temp
        }))
      } else {
        # Case when specific groups (ident.1, ident.2) are provided
        temp1 <- FoldChange(seurat_temp, features = x, ident.1 = ident.1, ident.2 = ident.2, slot = "data")
        names(temp1)[1] <- "FC"
        
        # Extract expression values for the two specified groups
        value.group1 <- as.numeric(GetAssayData(seurat_temp[, seurat_temp@meta.data[, ident.var] == ident.1])[x, ])
        if (is.null(ident.2)) {
          value.group2 <- as.numeric(GetAssayData(seurat_temp[, seurat_temp@meta.data[, ident.var] != ident.1])[x, ])
        } else {
          value.group2 <- as.numeric(GetAssayData(seurat_temp[, seurat_temp@meta.data[, ident.var] == ident.2])[x, ])
        }
        
        # Calculate p-value and adjust it using the Bonferroni method
        if (mean(value.group1, na.rm = TRUE) * mean(value.group2, na.rm = TRUE) > 0) {
          temp1$p.adj = p.adjust(p = wilcox.test(x = value.group1, y = value.group2)$p.value, method = "bonferroni", n = nrow(seurat))
        }
        
        # Name the columns with the prefix and the group names
        names(temp1) <- paste0(names(temp1), "_", prefix, "_", str_remove(ident.1, "_"), "-", str_remove(ident.2, "_"))
        temp1
      }
      
      # Add the marker gene name to the result
      temp1$gene <- x
      temp1
    }
  })
  
  # Stop parallel computation
  stopCluster(cl)
  
  # Combine the results into a single data frame
  candidate_markers_FC <- as.data.frame(rbindlist(candidate_markers_FC, use.names = TRUE, fill = TRUE))
  
  return(candidate_markers_FC)
}

```

### Function-DER enrichment
```{r}
FUN_DER_enrichment <- function(seurat, AUC.matrix, ident.var = NULL, OUTPUT_DIR = getwd(), prefix, loadfile = FALSE, plot = TRUE, NumCore = NULL, LIBLOC = .libPaths()) {
  # If ident.var is provided, use it for clustering, else use the default identity
  if (is.null(ident.var)) {
    print("No ident.var provided. Default identity will be used.")
  } else {
    if (!(ident.var %in% names(seurat@meta.data))) {
      print("Provided ident.var does not present in the SeuratObject.")
      break
    } else {
      print(paste("Setting identity to", ident.var))
      Idents(seurat) <- ident.var
    }
  }
  
  # Detect and set the number of cores to use for parallel processing
  if (is.null(NumCore)) {
    print("No NumCore is set. Automatically detecting the number of cores.")
    NumCore <- detectCores() - 1
  } else {
    if (NumCore > detectCores()) {
      print("NumCore is greater than the number of cores available. Automatically detecting the number.")
      NumCore <- detectCores() - 1
    }
  }
  
  # If loadfile is FALSE, perform the enrichment calculation
  if (isFALSE(loadfile)) {
    MATRIX <- AUC.matrix@assays@data@listData[["AUC"]]  # AUC matrix containing the regulon scores
    METADATA <- seurat@meta.data[ident.var]  # Metadata containing cluster identities
    colnames(METADATA) <- "Ident"
  
    # Initialize parallel computing
    cl <- makeCluster(detectCores() - 1)
    clusterExport(cl, c("METADATA", "MATRIX", "prefix", "LIBLOC"), envir = environment())
    clusterEvalQ(cl, .libPaths(LIBLOC))
    clusterEvalQ(cl, require(Seurat))
    clusterEvalQ(cl, require(data.table))
    clusterEvalQ(cl, require(parallel))
    
    # Differential enrichment analysis (DER) between clusters
    DER_res0.7 <- lapply(levels(factor(Idents(seurat))), FUN = function(y) {
      as.data.frame(rbindlist(parLapply(cl, rownames(AUC.matrix), fun = function(x) {
        print(paste("Comparing", y, "against others"))
        
        # Extract the AUC scores for the selected regulon (x) for each cluster
        value.group1 <- as.numeric(MATRIX[rownames(AUC.matrix) == x, rownames(subset(METADATA, Ident == y))])
        value.group2 <- as.numeric(MATRIX[rownames(AUC.matrix) == x, rownames(subset(METADATA, Ident != y))])
        
        # Perform the Wilcoxon test to compare the groups
        if (mean(value.group1, na.rm = TRUE) * mean(value.group2, na.rm = TRUE) > 0) {
          test.result <- wilcox.test(x = value.group1, y = value.group2)
          data.frame(regulon = x,
                     cluster = y,
                     p.value = test.result$p.value,
                     mean.1 = mean(value.group1, na.rm = TRUE),
                     mean.2 = mean(value.group2, na.rm = TRUE),
                     p.adj = p.adjust(p = test.result$p.value, method = "bonferroni", n = nrow(seurat)))
        }
      }), use.name = TRUE))
    })
    stopCluster(cl)
    
    DER_res0.7 <- as.data.frame(rbindlist(DER_res0.7, use.name = TRUE))
    
    # Calculate the difference in mean AUC between the two groups
    DER_res0.7$mean.diff <- DER_res0.7$mean.1 / DER_res0.7$mean.2
    DER_res0.7$rank <- DER_res0.7$mean.diff ^ DER_res0.7$mean.1
    
    # Extract the transcription factors from the regulon names
    DER_res0.7$regulon_tf <- sapply(DER_res0.7$regulon, FUN = function(x) { unlist(strsplit(x, split = "-", fixed = TRUE))[1] })
    DER_res0.7$regulon_tf <- sapply(DER_res0.7$regulon_tf, FUN = function(x) { unlist(strsplit(x, split = " ", fixed = TRUE))[1] })
    
    # Save the results as an Excel file
    write.xlsx(DER_res0.7, file = paste0(OUTPUT_DIR, "/", prefix, ".xlsx"))
  
  } else {
    # If loadfile is TRUE, read the pre-saved enrichment data
    DER_res0.7 <- read.xlsx(xlsxFile = paste0(OUTPUT_DIR, "/", prefix, ".xlsx"))
  }
  
  # Plot the results if plot is TRUE
  if (isTRUE(plot)) {
    # Create output directories if they don't exist
    if (!dir.exists(paste0(FIGURE_OUTPUTDIR, "/DER"))) {
      dir.create(paste0(FIGURE_OUTPUTDIR, "/DER"))
    }
    output_dir <- paste0(FIGURE_OUTPUTDIR, "/DER/", prefix)
    if (!dir.exists(output_dir)) {
      dir.create(output_dir)
    }
  
    # Generate scatter plots for each cluster
    lapply(levels(factor(DER_res0.7$cluster)), FUN = function(x) {
      temp <- subset(DER_res0.7, p.adj < 0.05 & mean.diff > 1 & cluster == x)
      p <- ggplot(data = temp, aes(x = mean.1, y = mean.diff)) +
        geom_point(colour = "grey") +
        geom_point(data = top_n(temp, 10, mean.diff ^ mean.1), colour = "red") +
        geom_text_repel(data = top_n(temp, 10, mean.diff ^ mean.1), aes(label = regulon), nudge_x = 0.5, nudge_y = 0.5) +
        theme_bw() +
        labs(title = paste0("Cluster ", x), x = paste0("Mean AUC in cluster ", x), y = "Mean AUC ratio")
      
      # Apply log scaling if the mean.diff range is wide
      if (max(temp$mean.diff) - min(temp$mean.diff) > 20) {
        p <- p + scale_y_continuous(trans = "log10") + ylab("log10 Mean AUC ratio")
      }
      
      # Save the plot as a TIFF file
      ggsave(plot = p, filename = paste0(output_dir, "/", x, ".tiff"), height = 9, width = 10, units = "cm", dpi = 600, device = "tiff", limitsize = FALSE)
    })
  }
  
  return(DER_res0.7)
}

```

### Monocle functions
```{r}
FUN_expression_prediction<-function (cds,gene,min_expr=NULL,size.factor=1e4,trend_formula = "~ splines::ns(pseudotime, df=3)"){

  {assertthat::assert_that(methods::is(cds, "cell_data_set"))
    cds_subset<-cds[rowData(cds)$gene_short_name %in% gene,]
    tryCatch({
      colData(cds_subset)$pseudotime <- pseudotime(cds_subset)
    }, error = function(x) {
      stop("No pseudotime calculated. Must call order_cells first.")
    })}
  # Checks if cds is a cell_data_set object, subset the cds for the selected genes.
  # If pseudotime is not calculated, stops the execution with an error message

  f_id <- NA
  Cell <- NA
  # Create empty variables for feature id and cell identifier

  cds_exprs <- cds_subset[,is.finite(colData(cds_subset)$pseudotime)]%>%SingleCellExperiment::logcounts()%>%as.matrix()%>%reshape2::melt()%>%data.frame()
  # Subsets the cds to cells with valid pseudotime, extracts log-transformed counts, and reshapes into a data frame.

  colnames(cds_exprs) <- c("f_id", "Cell", "expression")
  # Assigns column names to the expression data.

  cds_exprs <- inner_join(cds_exprs, data.frame(colData(cds_subset)), by=c("Cell"="Barcode"))
  # Merges the expression data with the metadata from cds.

  cds_exprs$f_id <- as.character(cds_exprs$f_id)
  cds_exprs$feature_label <- factor(as.character(cds_exprs$f_id))
  # Converts the feature id to character and assigns it as a factor for plotting.

  new_data <- as.data.frame(colData(cds_subset))
  new_data$Size_Factor = size.factor
  # Prepares a new data frame for model prediction with a size factor.

  model_tbl = fit_models(cds_subset, model_formula_str = trend_formula)
  model_expectation <- model_predictions(model_tbl, new_data = new_data)
  colnames(model_expectation) <- colnames(cds_subset)
  # Fits a model using the provided trend_formula and makes predictions using this model.

  expectation <- plyr::ddply(cds_exprs, plyr::.(f_id, Cell), 
    function(x) {
      data.frame(expectation = model_expectation[x$f_id, 
        x$Cell])
    })
  # Applies the model's expectation to the expression data for each feature and cell.

  cds_exprs <- merge(cds_exprs, expectation)
  # Merges the predictions with the original expression data.

  return(cds_exprs)
  # Returns the final expression data with model predictions.
}

FUN_plot_pseudotime<-function (cds,gene,min_expr=NULL,cell_size=0.5, 
                               color_cells_by="pseudotime",size.factor=1e4,
                               export.dir=NULL,nrow=NULL,ncol=2,individual.plot=FALSE,
                               trend_formula = "~ splines::ns(pseudotime, df=3)",
                               vertical_jitter = NULL, horizontal_jitter = NULL){

  {
    assertthat::assert_that(methods::is(cds, "cell_data_set"))
    cds_subset<-cds[rowData(cds)$gene_short_name %in% gene,]
    tryCatch({
      colData(cds_subset)$pseudotime <- pseudotime(cds_subset)
    }, error = function(x) {
      stop("No pseudotime calculated. Must call order_cells first.")
    })
    # Similar to the previous function, checks the cds object, subsets for selected genes, and calculates pseudotime

    assertthat::assert_that(color_cells_by %in% c("cluster", 
      "partition") | color_cells_by %in% names(colData(cds_subset)), 
      msg = paste("color_cells_by must be a column in the", 
        "colData table."))
    # Verifies that 'color_cells_by' is a valid column in colData.

    if (!is.null(nrow)) {assertthat::assert_that(assertthat::is.count(nrow))}
    assertthat::assert_that(assertthat::is.count(ncol))
    # Ensures 'nrow' and 'ncol' are positive integers if provided.
    
    }
  # End of checking section

  f_id <- NA
  Cell <- NA
  # Initializes variables for feature id and cell identifier.

  cds_exprs <- cds_subset[,is.finite(colData(cds_subset)$pseudotime)]%>%SingleCellExperiment::logcounts()%>%as.matrix()%>%reshape2::melt()%>%data.frame()
  # Similar to the previous function, it processes the expression data, applies log-transformation, and reshapes it.

  colnames(cds_exprs) <- c("f_id", "Cell", "expression")
  # Assigns column names.

  cds_exprs <- inner_join(cds_exprs, data.frame(colData(cds_subset)), by=c("Cell"="Barcode"))
  # Merges the expression data with the metadata.

  cds_exprs$f_id <- as.character(cds_exprs$f_id)
  cds_exprs$feature_label <- factor(as.character(cds_exprs$f_id))
  # Prepares the data for plotting with factor labels.

  new_data <- as.data.frame(colData(cds_subset))
  new_data$Size_Factor = size.factor
  # Prepares the new data frame with size factor.

  model_tbl = fit_models(cds_subset, model_formula_str = trend_formula)
  model_expectation <- model_predictions(model_tbl, new_data = new_data)
  colnames(model_expectation) <- colnames(cds_subset)
  # Fits a model to the data using the specified trend_formula and makes predictions.

  expectation <- plyr::ddply(cds_exprs, plyr::.(f_id, Cell), 
    function(x) {
      data.frame(expectation = model_expectation[x$f_id, 
        x$Cell])
    })
  # Applies model predictions to the expression data.

  cds_exprs <- merge(cds_exprs, expectation)
  # Merges the predicted expectations back into the data.

  #

  if(individual.plot & !is.null(export.dir)){
    # If individual plots are requested and export directory is provided,
    # we generate individual plots for each gene
    #cl<-makeCluster(detectCores()-1)
    #clusterExport(cl, c("cds_exprs","export.dir","LIBLOC"),envir=environment())
    #clusterEvalQ(cl, .libPaths(LIBLOC))
    #clusterEvalQ(cl, require(ggplot2))
    #clusterEvalQ(cl, require(viridisLite))
    #clusterEvalQ(cl, require(viridis))
    # Creates clusters and exports plots (code commented out)
    
    sapply(unique(cds_exprs$f_id),FUN=function(temp.gene){
      q <- ggplot(aes(pseudotime, expression), 
                  data = subset(cds_exprs,f_id==temp.gene))+
            geom_point(aes(color = pseudotime),size=0.75)+
            viridis::scale_color_viridis(option = "C")+
            geom_line(aes(x = pseudotime, y = expectation),
                      data = subset(cds_exprs,f_id==temp.gene))+
            labs(y="Expression",x="pseudotime",title=temp.gene)+
            theme_classic()+
            theme(legend.position="right",
                  text=element_text(size=12))
      ggsave(q,filename=paste0(export.dir,"/",temp.gene,".tiff"),
             width=8,height=6,dpi=150,units="cm")
      })
    # For each gene, it plots expression against pseudotime with color indicating pseudotime and saves the plot to the directory.
    
    #stopCluster(cl)
    return(cds_exprs)
  }else{
    q <- ggplot(aes(pseudotime, expression),
                    data = cds_exprs)
        if (!is.null(color_cells_by)) {
          q <- q + geom_point(aes_string(color = color_cells_by),size=0.75,
                              position = position_jitter(horizontal_jitter,
                                                         vertical_jitter))
          if (methods::is(colData(cds_subset)[, color_cells_by],"numeric")) {q <- q + viridis::scale_color_viridis(option = "C")}
        }else{
          q <- q + geom_point(size=0.75,position = position_jitter(horizontal_jitter, vertical_jitter))
          }
        q <- q + geom_line(aes(x = pseudotime, y = expectation),
                           data = cds_exprs)+
          facet_wrap(~feature_label, nrow = nrow, ncol = ncol, scales = "free_y")+
          labs(y="Expression",x="pseudotime")+
          theme_classic()+
          theme(legend.position="right")
        return(list(q,cds_exprs))
  }
  # If individual plots are not requested, it creates a combined plot for all genes with facets and an optional color grouping.
}


```


# Load data
```{r}
count<-fread(file=paste0(COUNT_INPUTDIR,"/count.csv"),data.table=FALSE)
# Load the count data from a CSV file, using fread for efficient loading. It's saved as a data frame.

rownames(count)<-fread(file=paste0(COUNT_INPUTDIR,"/rownames.csv"),data.table=FALSE)[,1]
# Load row names from another CSV file and assign them as the row names for the count data.

rownames(count)<-paste(str_split(rownames(count),"_",simplify=TRUE)[,2],str_split(rownames(count),"_",simplify=TRUE)[,1],sep="-")
# Modify the row names by splitting each name, swapping two parts, and joining them with a hyphen.

metadata<-data.frame(CellID=colnames(count))
# Create a metadata data frame using the column names (CellID) from the count data.

metadata$Barcode<-str_split(metadata$CellID,"_",simplify=TRUE)[,2]
# Extract the Barcode part from the CellID by splitting the string and storing it in a new column Barcode.

metadata$SampleID<-str_split(metadata$CellID,"_",simplify=TRUE)[,1]
# Extract the SampleID part from the CellID by splitting the string and storing it in a new column SampleID.

# Load SampleMetadata
sample_metadata<-read.xlsx(xlsxFile=paste0(PROJECT_DIR,"/SampleMetadata.xlsx"))
# Load sample metadata from an Excel file.

# merge
metadata<-left_join(metadata,sample_metadata,by="SampleID")
# Merge the metadata with the sample_metadata using SampleID as the key for the join.

rownames(metadata)<-metadata$CellID
# Set the row names of the metadata as the CellID column.

# load gene info
gene_info<-fread(file=paste0(PROJECT_DIR,"/gene_info.csv"),data.table=FALSE)
# Load gene information from a CSV file.

gene_info$Gene_ID<-paste(str_split(gene_info$Gene_ID,"_",simplify=TRUE)[,2],str_split(gene_info$Gene_ID,"_",simplify=TRUE)[,1],sep="-")
# Modify the Gene_ID by splitting it, swapping two parts, and joining them with a hyphen.

```


# Create Seurat
```{r}
seurat<-CreateSeuratObject(counts=as.matrix(count),
                           project="SGCE",
                           meta.data=metadata,
                           min.cells = 3, min.features = 200)
# Create a Seurat object from the count matrix.
# Convert the count data into a matrix if it is not already.
# The project name is set as "SGCE".
# The metadata from the previous step is added to the Seurat object.
# min.cells=3 means that genes must appear in at least 3 cells to be included.
# min.features=200 means that cells must have at least 200 detected features (genes) to be included.

```

# Filtering
```{r}
# keep protein coding genes only
seurat_coding<-seurat[rownames(seurat)%in%subset(gene_info,Gene_Biotype=="protein_coding")$Gene_ID,]
# This line filters the Seurat object to keep only the rows (genes) that are protein-coding.
# It does this by checking if the gene's name (from rownames(seurat)) is in the list of protein-coding genes.
# The protein-coding genes are obtained from the gene_info table where the Gene_Biotype is "protein_coding".

seurat_coding<-PercentageFeatureSet(seurat_coding, pattern = "^MT-",col.name = "percent.mt")
# This line calculates the percentage of mitochondrial genes (those starting with "MT-") for each cell.
# The calculated percentage is stored in the metadata column "percent.mt".

seurat_neuron<-subset(seurat_coding,SampleGroup=="Interneuron")
# This line creates a new Seurat object for the Interneuron cells by subsetting the data based on the SampleGroup.
# Only cells labeled as "Interneuron" in the SampleGroup are kept in the seurat_neuron object.

seurat_astrocyte<-subset(seurat_coding,SampleGroup=="Astrocyte")
# This line creates another Seurat object for Astrocyte cells by subsetting the data based on the SampleGroup.
# Only cells labeled as "Astrocyte" in the SampleGroup are kept in the seurat_astrocyte object.

```

## Cell filtering
### scater
```{r}
sce<-SingleCellExperiment(list(counts=GetAssayData(seurat_neuron)),colData=as.data.frame(seurat_neuron@meta.data))
# This line creates a SingleCellExperiment object (sce) from the Seurat object 'seurat_neuron'.
# The count data is extracted using GetAssayData, and the metadata is passed as colData.

discard.mito <- isOutlier(sce$percent.mt,
                          batch=sce$SampleID,
                          type="higher",
                          nmads=3)
# This line identifies cells with outlier mitochondrial gene percentages using the isOutlier function.
# Cells with a higher than normal "percent.mt" (mitochondrial gene percentage) are flagged as outliers based on 3 standard deviations (nmads=3).

discard.detected <- isOutlier(sce$nFeature_RNA,batch=sce$SampleID,type="lower",nmads=3)
# This line identifies cells with outlier numbers of detected features (genes) using isOutlier.
# Cells with lower than normal "nFeature_RNA" (number of features) are flagged as outliers based on 3 standard deviations (nmads=3).

discard.sum <- isOutlier(sce$nCount_RNA,batch=sce$SampleID,log=TRUE,type="both",nmads=3)
# This line identifies cells with outlier total RNA counts using isOutlier.
# It flags cells with unusually low or high "nCount_RNA" (total RNA count) based on 3 standard deviations in the log scale.

threshold<-data.frame(mito=t(as.matrix(attr(discard.mito, "thresholds"))),
                      detected=t(as.matrix(attr(discard.detected, "thresholds"))),
                      sum=t(as.matrix(attr(discard.sum, "thresholds"))))
threshold$SampleID<-rownames(threshold)
# This line creates a data frame 'threshold' to store the thresholds for each of the outlier tests (mito, detected, sum).
# The thresholds for each outlier detection are extracted from the attributes of discard.mito, discard.detected, and discard.sum.

p<-plotColData(sce,x="SampleID",y="percent.mt",colour_by=I(discard.mito),point_size=0.5)+
  theme_bw()+
  theme(axis.text.x=element_text(angle=45,hjust=1,vjust=1),
        legend.position="none")
ggsave(plot=p,filename=paste0(FIGURE_OUTPUTDIR,"/scater/filtering_discard_mito.tiff"),width=12,height=7,units="cm",dpi=300,device="tiff",limitsize = TRUE)
# This block of code creates a scatter plot for the mitochondrial percentage ("percent.mt") with the cells flagged for discarding (discard.mito).
# The plot is saved as a .tiff image in the specified directory.

p<-plotColData(sce,x="SampleID",y="nFeature_RNA",colour_by=I(discard.detected),point_size=0.5)+
  theme_bw()+
  theme(axis.text.x=element_text(angle=45,hjust=1,vjust=1),
        legend.position="none")
ggsave(plot=p,filename=paste0(FIGURE_OUTPUTDIR,"/scater/filtering_detected.tiff"),width=12,height=7,units="cm",dpi=300,device="tiff",limitsize = TRUE)
# This block of code creates a scatter plot for the number of detected features ("nFeature_RNA") with the cells flagged for discarding (discard.detected).
# The plot is saved as a .tiff image in the specified directory.

p<-plotColData(sce,x="SampleID",y="nCount_RNA",colour_by=I(discard.sum),point_size=0.5)+
  scale_y_continuous(trans="log10")+
  theme_bw()+
  theme(axis.text.x=element_text(angle=45,hjust=1,vjust=1),
        legend.position="none")
ggsave(plot=p,filename=paste0(FIGURE_OUTPUTDIR,"/scater/filtering_sum.tiff"),width=12,height=7,units="cm",dpi=300,device="tiff",limitsize = TRUE)
# This block of code creates a scatter plot for the total RNA count ("nCount_RNA") with the cells flagged for discarding (discard.sum).
# The y-axis is transformed to a log scale, and the plot is saved as a .tiff image in the specified directory.

reasons<-list(discard.mito.high=discard.mito,
              discard.detected.low=discard.detected,
              discard.sum=discard.sum)
# This line creates a list called 'reasons' to store the outlier detection results for each type (mito, detected, sum).

reasons$discard<-(reasons$discard.mito.high+
                    reasons$discard.detected.low+
                    reasons$discard.sum)>0
# This line creates a logical vector 'discard' within the 'reasons' list.
# It combines the three outlier detection results, marking a cell as "discarded" if any of the conditions is met.

rm(list=c("sce","discard.mito","discard.detected","discard.sum","threshold"))
# This line removes the temporary variables 'sce', 'discard.mito', 'discard.detected', 'discard.sum', and 'threshold' from the environment to free up memory.

```

#### scater filtering summary
```{r}
filtering_summary<-cbind(data.frame(seurat_neuron@meta.data),list.cbind(reasons)) %>% 
  group_by(SampleID) %>% 
  summarise(discard.mito=sum(discard.mito.high),
            discard.detected=sum(discard.detected.low),
            discard.sum=sum(discard.sum),
            discard=sum(discard)) %>%
  inner_join(y=sample_metadata,by="SampleID")
# This line creates a 'filtering_summary' data frame by combining the metadata of 'seurat_neuron' with the 'reasons' list (which stores the discard information).
# It then groups the data by 'SampleID' and calculates the total number of discarded cells for each reason (mito, detected, sum, total discard).
# Finally, it merges the resulting summary with the sample metadata.

write.xlsx(filtering_summary,file=paste0(ANALYSIS_OUTPUTDIR,"/Scater filtering summary.xlsx"))
# This line writes the 'filtering_summary' data frame to an Excel file at the specified output directory.

filtering_summary<-melt(filtering_summary,id.vars=names(sample_metadata))
# This line melts the 'filtering_summary' data frame to long format, making it easier for plotting by converting the summary statistics into key-value pairs.

p<-ggplot(data=subset(filtering_summary,variable!="discard"),
          aes(x=SampleID,y=value,fill=variable))+
  geom_bar(stat="identity")+
  scale_fill_tableau()+
  theme_bw()+
  facet_grid(.~CellLine,space="free",scales="free_x")+
  labs(y="Percent of cells discarded (%)",fill="Reason for discarding")+
  theme(legend.position = "bottom",
        text=element_text(size=12))+
  guides(fill=guide_legend(ncol=1))
# This block of code creates a bar plot using 'ggplot2'.
# The plot visualizes the percentage of cells discarded for each reason, grouped by 'SampleID' and faceted by 'CellLine'.
# The 'geom_bar(stat="identity")' creates bar plots, 'scale_fill_tableau()' sets a color scheme, and other aesthetics define the plot's style.
# The 'labs' function adds labels for the y-axis and legend, while 'theme' and 'guides' adjust the plot appearance.

ggsave(plot=p,filename=paste0(FIGURE_OUTPUTDIR,"/scater/filtering_summary.tiff"),width=12,height=10,units="cm",dpi=600,device="tiff",limitsize = TRUE)
# This line saves the plot as a .tiff file at the specified output directory with high resolution (600 dpi).

```


### Final cell level filtering
scater is not used
nCount_RNA > 2e4
nFeature_RNA > 5000
percent.mt < 10
```{r}
seurat_neuron_filtered<-subset(seurat_neuron,nCount_RNA>2e4 & nFeature_RNA>5000 & percent.mt<10)
# This line filters the 'seurat_neuron' object, keeping only the cells where the 'nCount_RNA' (RNA count) is greater than 20,000, 
# 'nFeature_RNA' (number of features detected) is greater than 5000, and 'percent.mt' (mitochondrial percentage) is less than 10%.

# Final cell filtering summary
temp<-data.frame(seurat_neuron@meta.data)
# This line extracts the metadata from the 'seurat_neuron' object and converts it into a data frame.

temp$discard.mito<-temp$percent.mt>=10
# This line creates a new column 'discard.mito' that flags cells with a mitochondrial percentage of 10% or greater.

temp$discard.sum<-temp$nCount_RNA<=2e4
# This line creates a new column 'discard.sum' that flags cells with RNA count less than or equal to 20,000.

temp$discard.detected<-temp$nFeature_RNA<=5000
# This line creates a new column 'discard.detected' that flags cells with fewer than or equal to 5000 detected features.

filtering_summary<-temp %>%
  group_by(SampleID) %>% 
  summarise(discard.mito=sum(discard.mito),
            discard.detected=sum(discard.detected),
            discard.sum=sum(discard.sum)) %>%
  inner_join(y=sample_metadata,by="SampleID")
# This block of code groups the 'temp' data frame by 'SampleID' and sums up the cells discarded for each reason (mito, detected, sum).
# It then merges this summary with the 'sample_metadata' data frame using 'SampleID'.

write.xlsx(filtering_summary,file=paste0(ANALYSIS_OUTPUTDIR,"/Final filtering summary.xlsx"))
# This line writes the final filtering summary to an Excel file in the specified output directory.

filtering_summary<-melt(filtering_summary,id.vars=names(sample_metadata))
# This line melts the 'filtering_summary' data frame to long format, making it easier for plotting by converting the summary statistics into key-value pairs.

p<-ggplot(data=subset(filtering_summary,variable!="discard"),
          aes(x=SampleID,y=value,fill=variable))+
  geom_bar(stat="identity")+
  scale_fill_tableau()+
  theme_bw()+
  facet_grid(.~CellLine,space="free",scales="free_x")+
  labs(y="Percent of cells discarded (%)",fill="Reason for discarding")+
  theme(legend.position = "bottom",
        text=element_text(size=12))+
  guides(fill=guide_legend(ncol=1))
# This block of code creates a bar plot using 'ggplot2'.
# It visualizes the percentage of cells discarded for each reason, grouped by 'SampleID' and faceted by 'CellLine'.
# The 'geom_bar(stat="identity")' creates bar plots, 'scale_fill_tableau()' sets a color scheme, and other aesthetics define the plot's style.
# The 'labs' function adds labels for the y-axis and legend, while 'theme' and 'guides' adjust the plot appearance.

ggsave(plot=p,filename=paste0(FIGURE_OUTPUTDIR,"/filtering_summary.tiff"),width=12,height=10,units="cm",dpi=600,device="tiff",limitsize = TRUE)
# This line saves the plot as a .tiff file at the specified output directory with high resolution (600 dpi).

```


## Gene filtering
expressed in at least 1% cells (>=13)
with at least 5 counts across all cells (in effect no additional filtering applied)
```{r}
# This line filters the 'seurat_neuron_filtered' object to keep only cells where AraC is FALSE and Patient is "PT2".
seurat_neuron_filtered<-subset(seurat_neuron_filtered,AraC==FALSE & Patient=="PT2")

# The following block is commented out, but if executed, it would:
# 1. Get the raw counts data from the 'seurat_neuron_filtered' object.
# 2. Create a cluster using one less than the total number of cores available.
# 3. Export the 'temp' variable (which holds the counts data) to the cluster workers.
# 4. Apply the function 'sum(x>0)' across rows of the 'temp' data to count the number of non-zero values (cells expressing each gene).
# 5. Stop the cluster after the operation.
# '{temp<-(GetAssayData(seurat_neuron_filtered,layer="counts"))
# cl <- makeCluster(detectCores()-1)
# clusterExport(cl, "temp")
# feature_ncell<-parApply(cl,temp,MARGIN=1,FUN=function(x){sum(x>0)})
# stopCluster(cl)}'

# This line filters the 'seurat_neuron_filtered' object to keep only genes that are expressed in at least 1% of the cells,
# and whose total count across all cells is greater than or equal to 5.
seurat_neuron_filtered<-seurat_neuron_filtered[feature_ncell>ncol(seurat_neuron_filtered)*0.01 & rowSums(GetAssayData(seurat_neuron_filtered,layer="counts"))>=5,]

# This line removes the temporary 'temp' variable from the workspace.
rm(temp)

```



# Reduction
## Normalisation testing
Use 1e5
```{r include=FALSE}
# Create a vector 'test_factors' containing different scaling factors for normalization.
test_factors<-c(1e3,1e4,2.5e4,5e4,7.5e4,1e5,1e6)

# Extract raw counts data from the 'seurat_neuron_filtered' object and store it in 'temp_before'.
temp_before<-as.vector(GetAssayData(seurat_neuron_filtered,layer="counts"))

# Create a histogram of the raw counts (only values greater than 0) before normalization and save it as a .tiff file.
p1<-ggplot(data=data.frame(m=temp_before[temp_before>0]),aes(x=m))+geom_histogram()
ggsave(p1,filename=paste0(FIGURE_OUTPUTDIR,"/Normalisation comparison/Dataset_Before.tiff"),width=9,height=6,units="cm",dpi=300)

# Loop through each value in 'test_factors', apply normalization, and generate histograms for each scaling factor.
comparison<-lapply(test_factors,FUN=function(x){
  # Normalize the 'seurat_neuron_filtered' object using the current scaling factor 'x' and extract the normalized data.
  temp_after<-as.vector(GetAssayData(NormalizeData(seurat_neuron_filtered,scale.factor=x),slot="data"))
  
  # Create a histogram of the normalized counts (only values greater than 0) for the current scaling factor 'x'.
  p1<-ggplot(data=data.frame(m=temp_after[temp_after>0]),aes(x=m))+geom_histogram()
  
  # Save the histogram as a .tiff file with a filename indicating the scaling factor used.
  ggsave(p1,filename=paste0(FIGURE_OUTPUTDIR,"/Normalisation comparison/Dataset_",x/1000,"K.tiff"),width=9,height=6,units="cm",dpi=300)
})

# Remove temporary variables from the workspace to free up memory.
rm(list=c("test_factors","temp_before","p1","comparison"))

```

## Normalisation
```{r}

# Normalize the 'seurat_neuron_filtered' data using a scale factor of 1e4 and assign the result to 'seurat_normalised'.
seurat_normalised<-NormalizeData(seurat_neuron_filtered,scale.factor=1e4)

# Read in the expression matrix file containing data for cell cycle scoring.
exp.mat <- read.table(file=paste0(PROJECT_DIR,"/nestorawa_forcellcycle_expressionMatrix.txt"), header = TRUE, as.is = TRUE, row.names = 1)

# Perform cell cycle scoring by using the 'CellCycleScoring' function on the normalized Seurat object. 
# It assigns cell cycle phase information to cells based on the provided gene sets for S and G2M phases.
seurat_normalised <- CellCycleScoring(seurat_normalised, s.features = FUN_gene(cc.genes$s.genes), g2m.features = FUN_gene(cc.genes$g2m.genes), set.ident = TRUE)

# Generate a bar plot showing the number of cells in each cell cycle phase, grouped by 'CellLine' and 'SampleID'.
p<-seurat_normalised@meta.data %>% 
  group_by(CellLine,SampleID,Phase) %>%  # Group data by cell line, sample ID, and phase.
  summarise(n()) %>%  # Count the number of cells in each group.
  ggplot(aes(x=SampleID,y=`n()`,fill=Phase)) +  # Create a plot with sample ID on the x-axis and the count on the y-axis, color by cell cycle phase.
    geom_bar(stat="identity") +  # Use bar plot with height proportional to the count.
    scale_fill_colorblind() +  # Use colorblind-friendly color palette for filling the bars.
    theme_bw() +  # Use a black and white theme for the plot.
    facet_grid(.~CellLine,space="free",scales="free_x") +  # Facet by 'CellLine' to create separate panels for each cell line.
    labs(y="Number of cells",fill="Cell cycle phase") +  # Label the y-axis and the legend.
    theme(legend.position = "right",  # Position the legend to the right.
          text=element_text(size=12),  # Set text size for labels.
          axis.text.x=element_text(angle=90,hjust=1,vjust=0.5))  # Rotate x-axis labels to make them readable.

# Save the bar plot as a .tiff file in the specified output directory.
ggsave(plot=p,filename=paste0(FIGURE_OUTPUTDIR,"/Phase_bySampleGroup.tiff"),width=12,height=8,units="cm",dpi=300,device="tiff",limitsize = TRUE)


```


## Scaling
```{r}
# Identify the most variable features (genes) in the normalized Seurat object.
seurat_normalised<-FindVariableFeatures(seurat_normalised)

# Create a plot displaying the variable features identified in the Seurat object.
p<-VariableFeaturePlot(seurat_normalised) + theme_bw()  # Apply black and white theme to the plot.

# Save the plot of variable features as a .tiff file in the specified output directory.
ggsave(plot=p,filename=paste0(FIGURE_OUTPUTDIR,"/VariableFeatures.tiff"),width=12,height=7,units="cm",dpi=300,device="tiff",limitsize = TRUE)

# Scale the data in the Seurat object while regressing out the 'percent.mt' variable to correct for mitochondrial gene expression.
seurat_normalised<-ScaleData(seurat_normalised,vars.to.regress=c("percent.mt"))

```

## PCA
```{r include=FALSE}
# Perform Principal Component Analysis (PCA) on the normalized Seurat object.
seurat_normalised <- RunPCA(seurat_normalised)

# Create an elbow plot to visualize the variance explained by the first 50 principal components (optional line commented out).
# DimHeatmap(seurat_normalised, dims = 1:20, cells = 1000, balanced = TRUE)

# Generate an Elbow plot for the first 50 principal components, indicating the number of components to retain.
p <- ElbowPlot(seurat_normalised, ndims=50) + theme(plot.background = element_rect(fill="white"))

# Save the Elbow plot as a .tiff file in the specified output directory.
ggsave(plot=p, filename=paste0(FIGURE_OUTPUTDIR,"/ElbowPlot.tiff"), width=12, height=8, units="cm", dpi=300, device="tiff", limitsize = TRUE)

# Perform JackStraw analysis to assess the significance of principal components.
seurat_normalised <- JackStraw(seurat_normalised, num.replicate = 100, dims=50)

# Score the JackStraw analysis results for the first 50 principal components.
seurat_normalised <- ScoreJackStraw(seurat_normalised, dims = 1:50)

# Generate a JackStraw plot to visualize the significance of the principal components.
p <- JackStrawPlot(seurat_normalised, dims = 1:50) + theme(legend.position="bottom", text=element_text(size=10), plot.background=element_rect(fill="white")) + labs(colour="PC:\nvalue") + guides(colour=guide_legend(ncol=4))

# Save the JackStraw plot as a .tiff file in the specified output directory.
ggsave(plot=p, filename=paste0(FIGURE_OUTPUTDIR,"/JackStrawPlot.tiff"), width=16, height=14, units="cm", dpi=300, device="tiff", limitsize = TRUE)

# Choose the dimensions (principal components) to use for further analysis, here selecting the first 20.
dims.chosen = 1:20

# Run UMAP (Uniform Manifold Approximation and Projection) for dimensionality reduction using PCA results.
seurat_normalised <- RunUMAP(seurat_normalised, reduction = "pca", dims = dims.chosen, return.model = TRUE, reduction.name = "umap_pca")

```


## Integration
```{r}
# Split the RNA assay by "CellLine" in the Seurat object.
seurat_normalised[["RNA"]] <- split(seurat_normalised[["RNA"]], f = seurat_normalised$CellLine)

# Perform integration of layers using different methods: CCA, RPCA, Harmony, and FastMNN. 
# The dimensionality reduction "pca" is used for integration and new reductions are created for each method.
seurat_normalised <- IntegrateLayers(object = seurat_normalised, method = CCAIntegration, orig.reduction = "pca", dims = dims.chosen, new.reduction = "integrated.cca") %>%
  IntegrateLayers(method = RPCAIntegration, orig.reduction = "pca", new.reduction = "integrated.rpca") %>%
  IntegrateLayers(method = HarmonyIntegration, orig.reduction = "pca", new.reduction = "harmony") %>%
  IntegrateLayers(method = FastMNNIntegration, orig.reduction = "pca", new.reduction = "integrated.mnn")

# Run UMAP using different integrated reductions: CCA, RPCA, Harmony, and MNN.
seurat_normalised <- seurat_normalised %>%
  RunUMAP(reduction = "integrated.cca", dims = dims.chosen, reduction.name = "umap_cca") %>%
  RunUMAP(reduction = "integrated.rpca", dims = dims.chosen, reduction.name = "umap_rpca") %>%
  RunUMAP(reduction = "integrated.mnn", dims = dims.chosen, reduction.name = "umap_mnn") %>%
  RunUMAP(reduction = "harmony", dims = dims.chosen, reduction.name = "umap_harmony")

# Generate and save a plot comparing the different UMAP reductions (PCA, Harmony, CCA, RPCA, MNN) with the "CellLine" grouping and the expression of the gene "SNAP25".
p <- (DimPlot(seurat_normalised, reduction = "umap_pca", group.by = "CellLine", label = TRUE) + scale_colour_tableau("Tableau 10")) +
  (FeaturePlot(seurat_normalised, reduction = "umap_pca", features = FUN_gene("SNAP25"))) +
  (DimPlot(seurat_normalised, reduction = "umap_harmony", group.by = "CellLine", label = TRUE) + scale_colour_tableau("Tableau 10")) +
  (FeaturePlot(seurat_normalised, reduction = "umap_harmony", features = FUN_gene("SNAP25"))) +
  (DimPlot(seurat_normalised, reduction = "umap_cca", group.by = "CellLine", label = TRUE) + scale_colour_tableau("Tableau 10")) +
  (FeaturePlot(seurat_normalised, reduction = "umap_cca", features = FUN_gene("SNAP25"))) +
  (DimPlot(seurat_normalised, reduction = "umap_rpca", group.by = "CellLine", label = TRUE) + scale_colour_tableau("Tableau 10")) +
  (FeaturePlot(seurat_normalised, reduction = "umap_rpca", features = FUN_gene("SNAP25"))) +
  (DimPlot(seurat_normalised, reduction = "umap_mnn", group.by = "CellLine", label = TRUE) + scale_colour_tableau("Tableau 10")) +
  (FeaturePlot(seurat_normalised, reduction = "umap_mnn", features = FUN_gene("SNAP25")))

# Save the generated comparison plot as a .tiff file.
ggsave(plot = p, filename = paste0(FIGURE_OUTPUTDIR, "/Integration testing.tiff"), width = 35, height = 25, units = "cm", dpi = 300, device = "tiff", limitsize = TRUE)

# Join all layers together after integration.
seurat_normalised <- JoinLayers(seurat_normalised)

```

## Plot
```{r include=FALSE}
# Define a list of categorical variables from the Seurat object's metadata, specifically columns 6, 7, 9 to 17, and 22.
META_VARIABLE <- c(names(seurat_normalised@meta.data)[c(6:7, 9:17, 22)])

# For each categorical variable in META_VARIABLE, generate UMAP plots based on PCA reduction and save them.
lapply(META_VARIABLE, FUN = function(x) {
  # Create UMAP plot using PCA reduction, group by the categorical variable 'x', and shuffle the data for variability.
  p <- ggplot(data = DimPlot(object = seurat_normalised, reduction = "umap_pca", group.by = x, shuffle = TRUE)$data,
       aes(x = umappca_1, y = umappca_2, colour = .data[[x]])) +
    geom_point(size = 0.5, alpha = 1) +  # Add points with specified size and transparency.
    scale_colour_manual(values = colour_palette) +  # Set custom color palette.
    theme_bw() +  # Apply black and white theme.
    theme(legend.position = "bottom", text = element_text(size = 10)) +  # Customize theme and legend.
    guides(colour = guide_legend(nrow = 2, override.aes = list(size = 1.5, alpha = 1)))  # Customize legend.
  # Save the plot with a filename that includes the variable name 'x'.
  ggsave(plot = p, filename = paste0(FIGURE_OUTPUTDIR, "/Reduction/UMAP_PCA/UMAP_by", x, ".tiff"), width = 12, height = 10, units = "cm", dpi = 300, device = "tiff", limitsize = TRUE)
})

# Repeat the same process as above, but for UMAP plots based on Harmony reduction.
lapply(META_VARIABLE, FUN = function(x) {
  # Create UMAP plot using Harmony reduction, group by the categorical variable 'x', and shuffle the data for variability.
  p <- ggplot(data = DimPlot(object = seurat_normalised, reduction = "umap_harmony", group.by = x, shuffle = TRUE)$data,
       aes(x = umapharmony_1, y = umapharmony_2, colour = .data[[x]])) +
    geom_point(size = 0.5, alpha = 1) +  # Add points with specified size and transparency.
    scale_colour_manual(values = colour_palette) +  # Set custom color palette.
    theme_bw() +  # Apply black and white theme.
    theme(legend.position = "bottom", text = element_text(size = 10)) +  # Customize theme and legend.
    guides(colour = guide_legend(nrow = 2, override.aes = list(size = 1.5, alpha = 1)))  # Customize legend.
  # Save the plot with a filename that includes the variable name 'x'.
  ggsave(plot = p, filename = paste0(FIGURE_OUTPUTDIR, "/Reduction/UMAP/UMAP_Harmony_by", x, ".tiff"), width = 12, height = 10, units = "cm", dpi = 300, device = "tiff", limitsize = TRUE)
})



```




# Clustering
using harmony for clustering

```{r include=FALSE}
# Define the number of dimensions chosen for the analysis (1 to 20).
dims.chosen = 1:20

# Find neighbors in the Seurat object based on the chosen dimensions using the Harmony reduction method.
seurat_normalised <- FindNeighbors(seurat_normalised, dims = dims.chosen, verbose = TRUE, reduction = "harmony")

# Perform Seurat clustering using a custom function 'FUN_seurat_clustering' for the Harmony UMAP reduction.
# Store the resulting clustering information in the 'seurat_normalised_cluster_list'.
seurat_normalised_cluster_list <- FUN_seurat_clustering(seurat_normalised, "Clustering_UMAP", "umap_harmony")

# Rename the elements of the 'seurat_normalised_cluster_list' by applying a sequence of values from 1 to 20 divided by 10.
names(seurat_normalised_cluster_list) <- seq(1, 20) / 10


```


## Stat
```{r}
# Create a clustering summary dataframe by summarizing the number of cells in each cluster across different clustering results (1 to 20).
clustering_summary <- as.data.frame(t(rbindlist(lapply(1:20, FUN = function(i) {
  # Extract the number of cells in each cluster from the seurat_clusters attribute of each clustering result.
  temp <- as.data.frame(t(data.frame(NumCell = summary(seurat_normalised_cluster_list[[i]]$seurat_clusters))))
}), fill = TRUE)))

# Assign appropriate names to the columns of the clustering summary based on the names of the clustering results.
names(clustering_summary) <- names(seurat_normalised_cluster_list)

# Iterate through each clustering result (1 to 20) to generate clustering summaries and visualizations.
sapply(1:20, FUN = function(i) {
  # Create a new directory for each clustering result, if it does not already exist.
  if (!dir.exists(paste0(FIGURE_OUTPUTDIR, "/Clustering summary/", names(seurat_normalised_cluster_list)[i])))
    dir.create(paste0(FIGURE_OUTPUTDIR, "/Clustering summary/", names(seurat_normalised_cluster_list)[i]))

  # Get the current clustering result.
  temp <- seurat_normalised_cluster_list[[i]]

  # Create a summary plot by CellLine and seurat_clusters showing the percentage of cells in each cluster for each sample.
  x <- temp@meta.data %>%
    group_by(seurat_clusters, CellLine, Sample) %>%
    summarise(n = n()) %>%
    inner_join(temp@meta.data %>% group_by(seurat_clusters) %>% summarise(NumCell = n()), by = "seurat_clusters")
  p <- ggplot(data = x,
              aes(x = seurat_clusters, y = Sample, fill = (n / NumCell) * 100)) +
    geom_tile(lwd = 0.5, linetype = 1, colour = "black") +
    geom_text(aes(label = n)) +
    theme_classic() +
    facet_grid(CellLine ~ ., scales = "free_y", space = "free") +
    scale_fill_gradient(high = "red", low = "white") +
    guides(fill = guide_colourbar(title = "Percent of cells\nin cluster (%)"))
  ggsave(plot = p, filename = paste0(FIGURE_OUTPUTDIR, "/Clustering summary/", names(seurat_normalised_cluster_list)[i], "/Sample_inSeuratClusters.tiff"), width = 13, height = 8, units = "cm", dpi = 300, device = "tiff", limitsize = TRUE)

  # Create a summary plot by Sample showing the percentage of cells in each cluster for each sample.
  x <- temp@meta.data %>%
    group_by(seurat_clusters, CellLine, Sample) %>%
    summarise(n = n()) %>%
    inner_join(temp@meta.data %>% group_by(Sample) %>% summarise(NumCell = n()), by = "Sample")
  p <- ggplot(data = x,
              aes(x = seurat_clusters, y = Sample, fill = (n / NumCell) * 100)) +
    geom_tile(lwd = 0.5, linetype = 1, colour = "black") +
    geom_text(aes(label = n)) +
    theme_classic() +
    facet_grid(CellLine ~ ., scales = "free_y", space = "free") +
    scale_fill_gradient(high = "red", low = "white") +
    guides(fill = guide_colourbar(title = "Percent of cells\nin cluster (%)"))
  ggsave(plot = p, filename = paste0(FIGURE_OUTPUTDIR, "/Clustering summary/", names(seurat_normalised_cluster_list)[i], "/Sample_inSample.tiff"), width = 13, height = 8, units = "cm", dpi = 300, device = "tiff", limitsize = TRUE)

  # Create a summary plot showing the distribution of cells across different cell cycle phases (Phase).
  x <- temp@meta.data %>%
    group_by(seurat_clusters, Phase) %>%
    summarise(N = n())
  p <- ggplot(data = x,
              aes(x = seurat_clusters, y = N, fill = Phase)) +
    geom_bar(stat = "identity") +
    scale_fill_tableau() +
    theme_bw() +
    labs(y = "Number of cells", fill = "Cell cycle phase") +
    theme(legend.position = "bottom", text = element_text(size = 12))
  ggsave(plot = p, filename = paste0(FIGURE_OUTPUTDIR, "/Clustering summary/", names(seurat_normalised_cluster_list)[i], "/Phase.tiff"), width = 13, height = 8, units = "cm", dpi = 300, device = "tiff", limitsize = TRUE)

})

```


# Expression
## Marker expression-overview

```{r include=FALSE}
# Create a list of marker genes with their associated cell class.
marker_list <- temp_feature

# Assign column names to the marker list (gene and cell class).
names(marker_list) <- c("gene", "CellClass")

# Convert gene names in the marker list to their corresponding gene IDs using the gene_info data.
marker_list$gene <- mapvalues(marker_list$gene, from = gene_info$Gene_Name, to = gene_info$Gene_ID)

# Call the function to plot marker gene expression on UMAP using the "umap_harmony" reduction.
FUN_marker_expression_umap_seurat(seurat_normalised, marker_list, "umap_harmony")

```


## Use res0.5
```{r}
# Select the Seurat object corresponding to the clustering result for a specific resolution (0.5) from the cluster list.
seurat_res1.7 <- seurat_normalised_cluster_list$`0.5`

# (The following lines are commented out, as they would load annotation data for clusters.)
# res1.7_annotation <- fread(file = paste0(ANALYSIS_OUTPUTDIR, "/res1.7 annotation.txt"), data.table = FALSE)
# res1.7_annotation$seurat_clusters <- as.factor(res1.7_annotation$seurat_clusters)

# Generate a bar plot showing the number of cells per cluster, grouped by CellLine.
p <- seurat_res1.7@meta.data %>%
  group_by(CellLine, seurat_clusters) %>%
  summarise(N = n()) %>%
  # (The following line is commented out, as it would join the annotation data for cluster information.)
  # inner_join(y = res1.7_annotation, by = "seurat_clusters") %>%
  ggplot(aes(x = seurat_clusters, y = N, fill = CellLine)) +
  geom_bar(stat = "identity", position = position_stack()) +
  scale_fill_tableau("Tableau 20") +
  theme_classic() +
  # (The following line is commented out, as it would facet by CellType, which is not provided.)
  # facet_grid(.~CellType, scales = "free_x") +
  theme(text = element_text(size = 12))

# Save the plot as a TIFF file with the specified dimensions and resolution.
ggsave(plot = p, filename = paste0(FIGURE_OUTPUTDIR, "/res0.5_summary.tiff"),
       height = 4, width = 6, dpi = 600, device = "tiff", limitsize = TRUE)

```


### Specific marker expression
```{r}
# (The following line is commented out as it loads annotation data for res1.7 clusters, which is currently unused.)
# res1.7_annotation <- fread(file = paste0(ANALYSIS_OUTPUTDIR, "/res1.7 annotation.txt"), data.table = FALSE)
# res1.7_annotation$seurat_clusters <- as.factor(res1.7_annotation$seurat_clusters)

# Set the default assay of the Seurat object (seurat_res1.7) to "RNA" for gene expression analysis.
DefaultAssay(seurat_res1.7) <- "RNA"

# Iterate through the unique lineage levels to create violin plots for selected marker genes.
sapply(levels(factor(temp_feature$Lineage)), FUN = function(x) {
  print(x)  # Print the current lineage being processed.

  # Create a subset of the marker genes for the current lineage and generate a violin plot of gene expression.
  tempdata <- VlnPlot(seurat_res1.7, features = FUN_gene(subset(temp_feature, Lineage == x)$Gene), 
                      stack = TRUE, fill.by = "ident", flip = TRUE)$data
  
  # Modify the 'feature' column to remove the '-E' part of the gene names.
  tempdata$feature <- str_split(tempdata$feature, "-E", simplify = TRUE)[, 1]
  
  # (The following line is commented out as it would join annotation data for cluster information.)
  # tempdata <- inner_join(tempdata, res1.7_annotation, by = c("ident" = "seurat_clusters"))
  
  # Create the violin plot using ggplot2.
  p <- ggplot(tempdata, aes(x = ident, y = expression, fill = ident)) +
    geom_violin(scale = "width", colour = "black") +
    # (The following line is commented out as it would add scatter points to the plot.)
    # geom_point(shape = 21, position = position_jitterdodge(jitter.width = 2, dodge.width = 2), size = 1, alpha = 0.75, stroke = 0) +
    facet_grid(feature ~ ., scales = "free_x", space = "free") +
    scale_fill_tableau() +
    theme_classic() +
    theme(legend.position = "left")
  
  # Save the plot as a TIFF file with dynamically determined dimensions based on the number of features and clusters.
  ggsave(plot = p, filename = paste0(FIGURE_OUTPUTDIR, "/Selected markers by res1.7/res1.7_", x, ".tiff"),
         height = length(subset(temp_feature, Lineage == x)$Gene) * 2, 
         width = length(levels(factor(tempdata$ident))) * 1.5 + 2,
         units = "cm", dpi = 300, device = "tiff", limitsize = FALSE)
})


```


## Heatmap for annotation
```{r}
# load the annotation file for res1.7 clustering data
res1.7_annotation<-fread(file=paste0(ANALYSIS_OUTPUTDIR,"/res1.7 annotation.txt"),data.table=FALSE)

# Make sure that the cluster data is considered as factors for easy manipulation
res1.7_annotation$seurat_clusters<-as.factor(res1.7_annotation$seurat_clusters)

# get the expression matrix for specific genes from the Seurat object
expression_matrix<-GetAssayData(seurat_res1.7[FUN_gene(unique(temp_feature$Gene)),],assay="RNA",slot="data")

# Store row names (genes) and column names (cell IDs)
ROWNAMES_TEMP<-rownames(expression_matrix)
COLNAMES_TEMP<-colnames(expression_matrix)

# remove the columns with zero expression across all cells
expression_matrix<-as.data.table(expression_matrix[,colSums(expression_matrix)>0])

# save gene names to a new column
expression_matrix$gene<-ROWNAMES_TEMP

# Clean the gene names by removing suffix "-E"
expression_matrix$gene<-str_split(expression_matrix$gene,"-E",simplify=TRUE)[,1]

# Reshape the data into long format
expression_matrix<-melt(expression_matrix,id.vars="gene") %>%
  full_join(y=temp_feature,by=c("gene"="Gene")) %>% # join with temp_feature to get additional gene info
  left_join(y=seurat_res1.7@meta.data,by=c("variable"="CellID")) %>% # join with metadata
  left_join(y=res1.7_annotation,by="seurat_clusters") # join with res1.7_annotation to get cluster info

# Remove any missing expression data
expression_matrix<-expression_matrix[!is.na(expression_matrix$value),]

# create the heatmap plot showing gene expression across clusters and cell types
p<-ggplot(data=expression_matrix,
          aes(y=reorder(variable,nCount_RNA),x=gene,fill=scale(value)))+ # reorder cells by their total RNA count
  geom_raster()+ # rasterize the plot for heatmap
  scale_fill_gradient(low="white",high="#ae017e")+ # color gradient from white to red
  facet_grid(CellType+seurat_clusters~Lineage,scales="free",space="free")+ # facet by cell type, clusters, and lineage
  labs(y="",x="",fill="")+ # remove labels for y and x axis
  theme_bw()+ # use black and white theme
  theme(plot.margin=unit(c(0,0,0,0),"cm"), # remove plot margin
        axis.text.x=element_blank(), # remove x axis labels
        axis.text.y=element_text(size=2), # reduce y axis text size
        legend.position="none", # remove the legend
        legend.title=element_blank(), # remove legend title
        legend.text=element_text(size=4), # reduce legend text size
        panel.spacing = unit(0.05, "lines")) # adjust spacing between facets

# save the heatmap as a TIFF file with specific dimensions and resolution
ggsave(plot=p,filename=paste0(FIGURE_OUTPUTDIR,"/Key markers_heatmap.tiff"),units="cm",width=30,height=12,dpi=300)

```



# res1.7 comparison
## Cluster DEG
```{r}
# Run differential expression (DEG) analysis by seurat clusters using MAST
DEG_seurat_clusters<-FUN_DEG_comparison(
  query=seurat_res1.7, # input Seurat object
  prefix="seurat_clusters", # prefix for file names
  ident.var="seurat_clusters", # variable used for comparison (cluster)
  comparison=NULL, # no specific comparison
  assay="RNA", # use RNA assay
  slot="data", # use data slot
  logFC=0.25, # log fold change threshold
  test.use="MAST", # statistical test used (MAST)
  latent.vars=c("CellLine")) # use CellLine as a latent variable

# Extract genes that are significant (p value adjusted < 0.05) for each cluster
query_temp<-lapply(unique(DEG_seurat_clusters$cluster),FUN=function(x){FUN_geneid(subset(DEG_seurat_clusters,cluster==x & p_val_adj<0.05)$gene)})
names(query_temp)<-unique(DEG_seurat_clusters$cluster) # name the list by cluster number

# Perform Gene Ontology (GO) analysis for significant DEG clusters
DEG_seurat_clusters_GO<-FUN_Geneset_Overlap(query=query_temp,universe=FUN_geneid(rownames(seurat_res1.7)),prefix="DEG_seurat_clusters_GO",OrgDb=org.Hs.eg.db,ont="All",keyType="SYMBOL",minGSSize=50,maxGSSize=500,nGO=20,pAdjustMethod="BH",pvalueCutoff=0.01,qvalueCutoff=0.05,pthreshold=0.05)

# Read the results of the GO analysis from a previously saved file
DEG_seurat_clusters_GO<-read.xlsx(paste0(ANALYSIS_OUTPUTDIR,"/Geneset Enrichment/DEG_seurat_clusters_GO_GO.xlsx"))

# Reduce GO terms based on p.adjust < 0.05 and organize them by cluster
DEG_seurat_clusters_GO_reduced<-lapply(unique(DEG_seurat_clusters_GO$Cluster),FUN=function(x){
  temp_data<-subset(DEG_seurat_clusters_GO,Cluster==x & ONTOLOGY=="BP" & p.adjust<0.05) # only consider BP ontology
  temp<-FUN_ReduceGO(go=temp_data) # reduce GO terms
  temp<-left_join(temp_data,temp$reducedTerms,by=c("ID"="go")) # join reduced terms with the original data
  # Calculate enrichment score for each term
  temp$EnrichmentScore<-((as.numeric(str_split(temp$GeneRatio,fixed("/"),simplify=TRUE)[,1]))/(as.numeric(str_split(temp$GeneRatio,fixed("/"),simplify=TRUE)[,2])))/((as.numeric(str_split(temp$BgRatio,fixed("/"),simplify=TRUE)[,1]))/(as.numeric(str_split(temp$BgRatio,fixed("/"),simplify=TRUE)[,2])))
  # Calculate ordering score for each GO term based on its parent term
  temp$Ordering<-sapply(1:nrow(temp),FUN=function(i){sum(as.numeric(subset(temp,parent==temp$parent[i])$EnrichmentScore))/nrow(subset(temp,parent==temp$parent[i]))})
  return(temp)
}) %>% rbindlist() %>% as.data.frame() # combine the results into a data frame

# Plot the reduced GO terms based on their enrichment scores and ordering
p<-DEG_seurat_clusters_GO_reduced %>%
  ggplot(aes(x=(EnrichmentScore),y=reorder(reorder(Description,EnrichmentScore),Ordering),fill=parent))+
  geom_bar(stat="identity")+# create bar plot
  labs(y="GO terms",x="Hypergeometric enrichment score")+# label axes
  facet_wrap(.~Cluster,scales="free_y",nrow=1)+ # facet by cluster
  #scale_fill_manual(values=colour_palette)+ # Optional: Customize color palette
  theme_classic()+ # Use classic theme
  theme(axis.text=element_text(size=7,colour="black"), # format axis text
        axis.line = element_line(linewidth=0.25), # add axis line
        legend.position="none", # remove legend
        panel.spacing = unit(0.05, "lines")) # adjust panel spacing
ggsave(plot=p,filename=paste0(FIGURE_OUTPUTDIR,"/DEG/DEG_seurat_clusters_GO.tiff"),units="cm",width=100,height=30,dpi=300) # save the plot

# Plot the reduced GO terms for each cluster, only keeping terms with the same parent
p<-DEG_disease_GO_reduced %>%
  subset(ID==parent) %>%
  ggplot(aes(x=(EnrichmentScore),y=reorder(Description,EnrichmentScore),fill=parent))+
  geom_bar(stat="identity")+# create bar plot
  labs(y="GO terms",x="Hypergeometric enrichment score")+# label axes
  facet_wrap(.~Cluster,scales="free_y",nrow=1)+ # facet by cluster
  #scale_fill_manual(values=colour_palette)+ # Optional: Customize color palette
  theme_classic()+ # Use classic theme
  theme(axis.text=element_text(size=7,colour="black"), # format axis text
        axis.line = element_line(linewidth=0.25), # add axis line
        legend.position="none", # remove legend
        panel.spacing = unit(0.05, "lines")) # adjust panel spacing
ggsave(plot=p,filename=paste0(FIGURE_OUTPUTDIR,"/DEG/DEG_seurat_clusters_GO_reduced.tiff"),units="cm",width=60,height=10,dpi=300) # save the plot

```

## Chip comparison
```{r}
# Select seurat object for specific cluster (seurat_res1.7 from cluster 1)
#seurat_res1.7<-seurat_normalised_cluster_list$`1`

# Perform DEG comparison between Chip and Neuron for clusters 1 and 2
DEG_Chip<-FUN_DEG_comparison(
  query=subset(seurat_res1.7,seurat_clusters%in%c(1,2)), # subset Seurat object to include clusters 1 and 2
  prefix="Chip_Neuron", # prefix for file names
  ident.var="Chip", # variable for comparison (Chip condition)
  comparison=NULL, # no specific comparison defined
  assay="RNA", # using RNA assay
  slot="data", # use data slot
  logFC=0.25, # log fold change threshold
  test.use="MAST", # statistical test used (MAST)
  latent.vars=c("CellLine")) # use CellLine as a latent variable

# Adjust avg_log2FC for clusters A and B (A stays as is, B is reversed)
DEG_Chip$avg_log2FC_new[DEG_Chip$cluster=="A"]<-DEG_Chip$avg_log2FC[DEG_Chip$cluster=="A"] # keep logFC for A as is
DEG_Chip$avg_log2FC_new[DEG_Chip$cluster=="B"]<-(-DEG_Chip$avg_log2FC[DEG_Chip$cluster=="B"]) # reverse logFC for B

# Create a volcano plot to visualize DEG results for Chip vs Neuron comparison
p<-DEG_Chip %>%
  ggplot(aes(x=avg_log2FC_new,y=-log10(p_val_adj),fill=pctratio))+# plot log2FC vs -log10 p-value adjusted
  geom_point(shape=21,,alpha=0.75,stroke=0.25,size=0.75)+ # plot points with specific style
  geom_vline(xintercept=0,linetype="dashed")+ # vertical line at logFC = 0
  geom_hline(yintercept=-log10(0.05),linetype="dashed")+ # horizontal line at p-value = 0.05
  scale_fill_gradient2(midpoint=0,low="black",mid="white",high="red",trans="log10")+ # color gradient for ratio of positive expression
  labs(x="log2 Fold change\nChip A vs B",y="-log10 p adjusted",fill="Ratio of\npositive")+ # label axes
  theme_classic()+ # classic theme
  theme(text=element_text(size=8)) # text size for better readability
ggsave(filename=paste0(FIGURE_OUTPUTDIR,"/DEG/DEG_Chip_Neuron_volcano.tiff"), # save the volcano plot
       plot=p,units="cm",dpi=600,width=7,height=5) # specify dimensions and resolution

# Print summary of clusters with p-value adjusted < 0.05
summary(factor(subset(DEG_Chip,p_val_adj<0.05)$cluster)) # summarize number of significant genes per cluster

```


## Mutant vs WT
### PT2-Neuron
```{r}
# Perform DEG comparison between Genotype Mutant and Corrected for clusters 1 and 2
DEG_Neuron_PT2_disease<-FUN_DEG_comparison(
  query=subset(seurat_res1.7,seurat_clusters%in%c(1,2)), # subset Seurat object to include clusters 1 and 2
  prefix="Neuron_PT2_disease", # prefix for file names
  ident.var="Genotype", # variable for comparison (Genotype)
  comparison=NULL, # no specific comparison defined
  assay="RNA", # using RNA assay
  slot="data", # use data slot
  logFC=0.25, # log fold change threshold
  test.use="wilcox") # statistical test used (Wilcoxon)

# Read in DEG results for Neuron_PT2_disease comparison
DEG_Neuron_PT2_disease<-read.xlsx(paste0(ANALYSIS_OUTPUTDIR,"/DEG/DEG_Neuron_PT2_disease.xlsx"))

# Adjust avg_log2FC for Mutant and Corrected clusters
DEG_Neuron_PT2_disease$avg_log2FC_new[DEG_Neuron_PT2_disease$cluster=="Mutant"]<-(-DEG_Neuron_PT2_disease$avg_log2FC[DEG_Neuron_PT2_disease$cluster=="Mutant"]) # reverse logFC for Mutant
DEG_Neuron_PT2_disease$avg_log2FC_new[DEG_Neuron_PT2_disease$cluster=="Corrected"]<-(DEG_Neuron_PT2_disease$avg_log2FC[DEG_Neuron_PT2_disease$cluster=="Corrected"]) # keep logFC for Corrected as is

# Create volcano plot for DEG results (Mutant vs Corrected)
p<-DEG_Neuron_PT2_disease %>%
  ggplot(aes(x=avg_log2FC_new,y=-log10(p_val_adj),fill=pctratio))+# plot log2FC vs -log10 p-value adjusted
  geom_point(shape=21,,alpha=0.75,stroke=0.15,size=0.75)+ # plot points with specific style
  geom_vline(xintercept=0,linetype="dashed")+ # vertical line at logFC = 0
  geom_hline(yintercept=-log10(0.05),linetype="dashed")+ # horizontal line at p-value = 0.05
  geom_text(aes(label=paste0(sum(subset(DEG_Neuron_PT2_disease,p_val_adj<0.05)$cluster=="Corrected")," DEGs"),x=2,y=30),colour="black")+# label for Corrected DEGs
  geom_text(aes(label=paste0(sum(subset(DEG_Neuron_PT2_disease,p_val_adj<0.05)$cluster=="Mutant")," DEGs"),x=-2,y=30),colour="black")+# label for Mutant DEGs
  scale_fill_gradient2(midpoint=0,low="black",mid="white",high="red",trans="log10")+ # color gradient for ratio of positive expression
  labs(x="log2 Fold change\nMutant vs Corrected",y="-log10 p adjusted",fill="Ratio of\npositive")+ # label axes
  theme_classic()+ # classic theme
  theme(text=element_text(size=8)) # text size for better readability
ggsave(filename=paste0(FIGURE_OUTPUTDIR,"/DEG/DEG_Neuron_PT2_disease_volcano.tiff"), # save the volcano plot
       plot=p,units="cm",dpi=300,width=7,height=5) # specify dimensions and resolution

# Create query for Gene Set Enrichment Analysis with DEGs (p-value adjusted < 0.05 and logFC >= 1)
query_temp<-lapply(unique(DEG_Neuron_PT2_disease$cluster),FUN=function(x){FUN_geneid(subset(DEG_Neuron_PT2_disease,cluster==x & p_val_adj<0.05 & avg_log2FC>=1)$gene)}) # filter for significant DEGs
names(query_temp)<-unique(DEG_Neuron_PT2_disease$cluster)

# Perform Gene Set Overlap using GSEA
DEG_disease_GO<-FUN_Geneset_Overlap(query=query_temp,universe=FUN_geneid(rownames(seurat_res1.7)),prefix="DEG_Neuron_PT2_disease",OrgDb=org.Hs.eg.db,ont="All",keyType="SYMBOL",minGSSize=50,maxGSSize=500,nGO=20,pAdjustMethod="BH",pvalueCutoff=0.01,qvalueCutoff=0.05,pthreshold=0.05)

# Read in Gene Set Enrichment results
DEG_disease_GO<-read.xlsx(paste0(ANALYSIS_OUTPUTDIR,"/Geneset Enrichment/DEG_Neuron_PT2_disease_GO.xlsx"))

# Reduce GO terms and calculate Enrichment Scores
# For each cluster in DEG_disease_GO, it subset the data where ontology is BP and p.adjust<0.05
DEG_disease_GO_reduced<-lapply(unique(DEG_disease_GO$Cluster),FUN=function(x){
  
  # It take only those rows in DEG_disease_GO where Cluster matches the current value and ontology is BP with p.adjust<0.05
  temp_data<-subset(DEG_disease_GO,Cluster==x & ONTOLOGY=="BP" & p.adjust<0.05) 
  
  # It apply the function FUN_ReduceGO on the subsetted data, which should reduce the GO terms based on some logic.
  temp<-FUN_ReduceGO(go=temp_data) 
  
  # It merge the reduced terms from FUN_ReduceGO back with the temp_data using left_join on 'ID' and 'go'
  temp<-left_join(temp_data,temp$reducedTerms,by=c("ID"="go")) 
  
  # It calculate the EnrichmentScore using the formula of GeneRatio and BgRatio
  temp$EnrichmentScore<-((as.numeric(str_split(temp$GeneRatio,fixed("/"),simplify=TRUE)[,1]))/(as.numeric(str_split(temp$GeneRatio,fixed("/"),simplify=TRUE)[,2])))/
    ((as.numeric(str_split(temp$BgRatio,fixed("/"),simplify=TRUE)[,1]))/(as.numeric(str_split(temp$BgRatio,fixed("/"),simplify=TRUE)[,2]))) 
  
  # It calculate the ordering based on EnrichmentScore for GO terms grouped by 'parent' term
  temp$Ordering<-sapply(1:nrow(temp),FUN=function(i){
    sum(as.numeric(subset(temp,parent==temp$parent[i])$EnrichmentScore))/nrow(subset(temp,parent==temp$parent[i]))
  }) 
  
  # It return the processed data for each cluster
  return(temp)
}) %>% rbindlist() %>% as.data.frame() 


# Save reduced GO terms results to file
write.xlsx(DEG_disease_GO_reduced,paste0(ANALYSIS_OUTPUTDIR,"/Geneset Enrichment/DEG_Neuron_PT2_disease_GO_reduced.xlsx"))

# Read in the reduced GO terms results
DEG_disease_GO_reduced<-read.xlsx(paste0(ANALYSIS_OUTPUTDIR,"/Geneset Enrichment/DEG_Neuron_PT2_disease_GO_reduced.xlsx"))

# Create bar plot for GO term enrichment scores
p<-DEG_disease_GO_reduced %>%
  ggplot(aes(x=(EnrichmentScore),y=reorder(reorder(Description,EnrichmentScore),Ordering),fill=parent))+
  geom_bar(stat="identity")+ # create bar plot
  labs(y="GO terms",x="Hypergeometric enrichment score")+ # label axes
  facet_wrap(.~Cluster,scales="free_y",nrow=1)+ # facet by Cluster
  scale_fill_manual(values=colour_palette)+ # color by parent
  theme_classic()+ # classic theme
  theme(axis.text=element_text(size=7,colour="black"), # style axis text
        axis.line = element_line(linewidth=0.25), # line thickness for axis
        legend.position="none", # remove legend
        panel.spacing = unit(0.05, "lines")) # spacing between panels
ggsave(plot=p,filename=paste0(FIGURE_OUTPUTDIR,"/DEG/DEG_disease_GO.tiff"),units="cm",width=25,height=30,dpi=300)

# Create bar plot for reduced GO term enrichment scores
p<-DEG_disease_GO_reduced %>%
  subset(ID==parent) %>% # filter for GO terms where ID matches parent
  ggplot(aes(x=(EnrichmentScore),y=reorder(Description,EnrichmentScore),fill=parent))+
  geom_bar(stat="identity")+ # create bar plot
  labs(y="GO terms",x="Hypergeometric enrichment score")+ # label axes
  facet_wrap(.~Cluster,scales="free_y",nrow=1)+ # facet by Cluster
  scale_fill_manual(values=colour_palette)+ # color by parent
  theme_classic()+ # classic theme
  theme(axis.text=element_text(size=7,colour="black"), # style axis text
        axis.line = element_line(linewidth=0.25), # line thickness for axis
        legend.position="none", # remove legend
        panel.spacing = unit(0.05, "lines")) # spacing between panels
ggsave(plot=p,filename=paste0(FIGURE_OUTPUTDIR,"/DEG/DEG_disease_GO_reduced.tiff"),units="cm",width=20,height=10,dpi=300)

```


# SCENIC
## Preparation
```{r}
# Importing SCENIC library which is used for single-cell gene regulatory network analysis
library(SCENIC)

# Convert the assay data from the seurat object to a matrix (expression matrix)
exprMat<-as.matrix(GetAssayData(seurat_res1.7))

# Remove the suffix after "-E" from the gene names and make them unique (if duplicates are present)
rownames(exprMat)<-make.unique(str_split(rownames(exprMat),"-E",simplify=TRUE)[,1])

# Create a data frame with cell metadata from the Seurat object
cellInfo<-as.data.frame(seurat_res1.7@meta.data)

# Save the expression matrix and cell information into an RData file for SCENIC analysis
save(list=c("exprMat","cellInfo"),file=paste0(SAVE_DIR,"/ForSCENIC.RData"))

```
## Preparing SCENIC
```{r}
# Specify the organism used for gene regulatory network analysis (HGNC in this case)
org <- "hgnc"

# Set the directory path for RcisTarget databases (where the SCENIC databases are stored)
dbDir <- paste0(PROJECT_DIR,"/SCENIC") # RcisTarget databases location

# Load the default database names for the specified organism (HGNC)
data(defaultDbNames)

# Update the first two default database names to match the specific required databases for HG38
defaultDbNames[[org]][1]<-"hg38_refseq-r80_500bp_up_and_100bp_down_tss.mc9nr.feather"
defaultDbNames[[org]][2]<-"hg38_refseq-r80_10kb_up_and_down_tss.mc9nr.feather"

# Set the list of databases to use for SCENIC analysis
dbs <- defaultDbNames[[org]]

# Load the motif annotation data for the organism HGNC (Human Gene Symbol annotations)
data(list="motifAnnotations_hgnc_v9",package="RcisTarget")

# Assign motif annotations to a variable
motifAnnotations_hgnc<-motifAnnotations_hgnc_v9

# Initialize SCENIC options with the specified parameters, including organism, database directory, and available databases
scenicOptions <- initializeScenic(org=org, dbDir=dbDir, dbs=dbs, datasetTitle="SCENIC_Maria", nCores=32)

# Save the SCENIC options to an RDS file for later use
saveRDS(scenicOptions, file=paste0(SAVE_DIR,"/scenicOptions2.Rds"))

```


## Regulon enrichment plot
```{r}
# Load the SCENIC AUC data from a file
regulonAUC<-readRDS(file=paste0(PROJECT_DIR,"/SCENIC/int/3.4_regulonAUC.Rds"))

# Add the AUC data from SCENIC as a new assay to the Seurat object
seurat_res1.7[["AUC"]]<-CreateAssayObject(counts=regulonAUC@assays@data@listData[["AUC"]][,colnames(regulonAUC@assays@data@listData[["AUC"]])%in%colnames(seurat_res1.7)])

# Convert the AUC data to a data frame with columns as CellID and the regulon values
AUC<-as.data.frame(t(regulonAUC@assays@data@listData[["AUC"]]))
AUC$CellID<-rownames(AUC)

# Reshape the AUC data to long format for easier processing
AUC<-melt(regulonAUC@assays@data@listData[["AUC"]],id.vars="CellID")
names(AUC)<-c("regulon","CellID","value")

# Extract the TF name from the regulon column by splitting based on space and underscore
AUC$regulon_tf<-str_split(AUC$regulon," ",simplify=TRUE)[,1]
AUC$regulon_tf<-str_split(AUC$regulon_tf,"_",simplify=TRUE)[,1]

# Load the annotation data for Seurat clusters from a text file
res1.7_annotation<-fread(file=paste0(ANALYSIS_OUTPUTDIR,"/res1.7 annotation.txt"),data.table=FALSE)
res1.7_annotation$seurat_clusters<-as.factor(res1.7_annotation$seurat_clusters)

# Merge AUC data with Seurat metadata to add cluster information
AUC<-inner_join(AUC,seurat_res1.7@meta.data,by="CellID")

# Merge AUC data with cluster annotations for additional metadata
AUC<-inner_join(AUC,res1.7_annotation,by="seurat_clusters")

# Loop through each TF regulon and generate violin plots for AUC values across different clusters
lapply(levels(factor(AUC$regulon_tf)),FUN=function(x){
  temp<-subset(AUC,regulon_tf==x) # Subset AUC data for the current TF regulon
  p<-ggplot(data=temp, # Generate violin plot for the current regulon
       aes(x=seurat_clusters,y=value,fill=seurat_clusters))+
      geom_violin(scale="width")+
      scale_fill_manual(values=colour_palette)+
      facet_grid(regulon~seurat_clusters,space="free",scales="free_x")+
      theme_bw()+
      theme(legend.position = "non")+
      labs(y="AUC",title=x) # Label the plot with AUC and the regulon name
  ggsave(plot=p,filename=paste0(FIGURE_OUTPUTDIR,"/SCENIC_AUC_tf/",x,".tiff"),width=16,height=length(levels(factor(temp$regulon)))*4+1,units="cm",dpi=300,device="tiff",limitsize = TRUE) # Save the plot
})

# Define marker genes and their associated cell types
MARKERS<-data.frame(gene=c("LMX1A","FOXA1","OTX2","LMX1B","EN1","ZNF91",
                             "ASCL1","SOX4","SOX11",
                             "NFIA","NFIB","HES1","SOX9","ATF3","RUNX2","LHX2","SRF","HCFC1",
                        "ERG","MYOD1","MYOG","MEF2C","FOXC1","HOXA9","LEF1","PAX3","SNAI1"),
                      cell_type=c(rep("mDA",6),
                                rep("Neuron",3),
                                rep("Astrocyte",9),
                                rep("Mesodermal",9)))

# Combine lineage and cell type information in Seurat object and create a new column
seurat_cluster_res0.7$Lineage_Type<-paste(seurat_cluster_res0.7$Lineage,seurat_cluster_res0.7$Type,sep="_")

# Loop through each cell type and generate violin plots for marker genes' AUC values across clusters
sapply(levels(factor(MARKERS$cell_type)),FUN=function(x){
  features<-unlist(sapply(subset(MARKERS,cell_type==x)$gene,FUN=function(y){grep(pattern=y,x=rownames(seurat_cluster_res0.7[["AUC"]]))})) # Find marker genes
  p<-VlnPlot(seurat_cluster_res0.7,assay="AUC",slot="counts",features=rownames(seurat_cluster_res0.7[["AUC"]])[features],stack=TRUE,fill.by="ident",flip=TRUE,split.by="Lineage_Type") # Generate violin plot for the marker genes
  temp_data<-p$data # Extract the data used for the plot
  temp_data$tf<-mapvalues(temp_data$feature,from=str_replace(string=regulon_match_list$regulon,pattern="_",replacement="-"),to=regulon_match_list$tf) # Map regulon names to TF names
  
  # Merge AUC data with Seurat metadata using Barcode for correlation
  AUC<-inner_join(AUC,seurat_cluster_res0.7@meta.data,by="Barcode")

  # Create the final exportable violin plot with facets for each TF and cell type
  p_export<-ggplot(data=temp_data,
                     aes(x=ident,y=expression,fill=split))+
      geom_violin()+
      facet_grid(tf~split,space="free_x",scales="free")+
      theme_bw()+
      theme(legend.position="right")+
      scale_fill_tableau("Tableau 10")+
      labs(x="seurat_clusters",y="AUC",title=x,fill="Cell type")+
      guides(fill=guide_legend(ncol=1))+
      scale_y_continuous(n.breaks=3) # Adjust y-axis ticks for better visualization

  # Save the plot to the specified directory
  ggsave(plot=p_export,filename=paste0(FIGURE_OUTPUTDIR,"/SCENIC_AUC/",x,".tiff"),height=length(levels(factor(temp_data$tf)))*2,width=length(levels(factor(seurat_cluster_res0.7$seurat_clusters)))*1+5,units="cm",dpi=300,device="tiff",limitsize = FALSE)
})

```

## DER analysis
```{r}
# Load the regulonAUC matrix from a RDS file, the file is stored in the "SCENIC/int" folder under PROJECT_DIR
regulonAUC<-readRDS(file=paste0(PROJECT_DIR,"/SCENIC/int/3.4_regulonAUC.Rds"))

# Create a temporary subset of regulonAUC, keeping only the columns that matches the ones in "Neuron1" and "Neuron2"
# annotations from the seurat_res1.7 dataset
regulonAUC_temp<-regulonAUC[,colnames(regulonAUC)%in%colnames(subset(seurat_res1.7,Annotation%in%c("Neuron1","Neuron2")))]

# Run the FUN_DER_enrichment function on a subset of the seurat_res1.7 dataset with "Neuron1" and "Neuron2" 
# annotations, with the regulonAUC_temp matrix as input.
DER_res1.7<-FUN_DER_enrichment(seurat=subset(seurat_res1.7,Annotation%in%c("Neuron1","Neuron2")),

                               # Pass regulonAUC_temp as the AUC.matrix parameter for the function.
                               AUC.matrix=regulonAUC_temp,

                               # Define "Genotype" as the identity variable for the analysis.
                               ident.var="Genotype",

                               # Specify the prefix for the results as "DER_res1.7_Neuron"
                               prefix="DER_res1.7_Neuron")

# Save the result of the differential enrichment analysis to an Excel file under the ANALYSIS_OUTPUTDIR 
# in the DEG folder with the name "DER_res1.7_Neuron.xlsx"
write.xlsx(DER_res1.7,file=paste0(ANALYSIS_OUTPUTDIR,"/DEG/DER_res1.7_Neuron.xlsx"))

```


## Use SCENIC for clustering
```{r}
# Load the regulonAUC object from the RDS file and extract the "AUC" data from its assays slot
regulonAUC<-readRDS(file=paste0(PROJECT_DIR,"/SCENIC/int/3.4_regulonAUC.Rds"))

# Extract the "AUC" matrix from the regulonAUC object
regulonAUC<-regulonAUC@assays@data@listData[["AUC"]]

# Add the AUC data to the seurat_res1.7 object as a new assay named "AUC"
seurat_res1.7[["AUC"]]<-CreateAssayObject(counts=regulonAUC@assays@data@listData[["AUC"]][,colnames(regulonAUC@assays@data@listData[["AUC"]])%in%colnames(seurat_res1.7)])

# Create a copy of seurat_res1.7 and assign it to seurat_res1.7_AUC
seurat_res1.7_AUC<-seurat_res1.7

# Set the default assay of seurat_res1.7_AUC to "AUC"
DefaultAssay(seurat_res1.7_AUC)<-"AUC"

# Scale the data in the "AUC" assay for the seurat_res1.7_AUC object
seurat_res1.7_AUC<-ScaleData(seurat_res1.7_AUC,assay="AUC")

# Perform PCA analysis on the "AUC" assay in the seurat_res1.7_AUC object using all the features
seurat_res1.7_AUC<-RunPCA(seurat_res1.7_AUC,features=rownames(seurat_res1.7_AUC),assay="AUC")

# Perform Harmony integration on the PCA results in the "AUC" assay, grouping by "CellLine"
seurat_res1.7_AUC<-RunHarmony(seurat_res1.7_AUC,features=rownames(seurat_res1.7_AUC),assay="AUC",group.by.vars=c("CellLine"),reduction.save="harmony_AUC")

# Run UMAP dimensionality reduction based on the Harmony results in the "AUC" assay
seurat_res1.7_AUC<-RunUMAP(seurat_res1.7_AUC,features=rownames(seurat_res1.7_AUC),assay="AUC",reduction.name="umap_AUC",reduction="harmony_AUC")

# Compute neighbors for the UMAP analysis in the "AUC" assay using the Harmony results
seurat_res1.7_AUC<-FindNeighbors(seurat_res1.7_AUC,features=rownames(seurat_res1.7_AUC),assay="AUC",reduction="harmony_AUC",graph.name="AUC_graph")

# Perform clustering on the "AUC" assay using the computed neighbors, setting resolution to 0.4
seurat_res1.7_AUC<-FindClusters(seurat_res1.7_AUC,assay="AUC",resolution=0.4,graph.name="AUC_graph")

# Map the original cell clusters from seurat_res1.7 to seurat_res1.7_AUC based on the CellID, and store the results in a new factor column
seurat_res1.7_AUC$seurat_clusters_RNA<-as.factor(as.numeric(mapvalues(seurat_res1.7_AUC$CellID,from=seurat_res1.7$CellID,to=seurat_res1.7$seurat_clusters))-1)

# Copy the seurat_clusters from seurat_res1.7_AUC to a new column seurat_clusters_AUC
seurat_res1.7_AUC$seurat_clusters_AUC<-seurat_res1.7_AUC$seurat_clusters

```
### Clustering testing
```{r}
# Apply the following steps for each value of x in the sequence 0.1, 0.2, ..., 1
lapply(seq(1:10)/10,FUN=function(x){

  # Run the FindClusters function with the current resolution (x) on the seurat_res1.7_AUC object for the "AUC" assay
  temp<-FindClusters(seurat_res1.7_AUC,assay="AUC",resolution=x,graph.name="AUC_graph")

  # Map the clusters from seurat_res1.7 to the temp object based on CellID, and assign it to seurat_clusters_RNA
  temp$seurat_clusters_RNA<-as.factor(as.numeric(mapvalues(temp$CellID,from=seurat_res1.7$CellID,to=seurat_res1.7$seurat_clusters))-1)

  # Copy the seurat_clusters to a new column "seurat_clusters_AUC"
  temp$seurat_clusters_AUC<-temp$seurat_clusters

  # Create a plot with four DimPlot variations, comparing "seurat_clusters_RNA" and "seurat_clusters_AUC"
  p<-(DimPlot(temp,label=TRUE,group.by="seurat_clusters_RNA",reduction="umap_harmony")+scale_colour_tableau("Tableau 10"))+
    (DimPlot(temp,label=TRUE,group.by="seurat_clusters_AUC",reduction="umap_harmony")+scale_colour_tableau("Tableau 10"))+
    (DimPlot(temp,label=TRUE,group.by="seurat_clusters_RNA",reduction="umap_AUC")+scale_colour_tableau("Tableau 10"))+
    (DimPlot(temp,label=TRUE,group.by="seurat_clusters_AUC",reduction="umap_AUC")+scale_colour_tableau("Tableau 10"))

  # Save the plot as a TIFF file with resolution-specific name
  ggsave(plot=p,filename=paste0(FIGURE_OUTPUTDIR,"/UMAP_clustering_RNA_vs_AUC/res",x,".tiff"),height=16,width=18,units="cm",dpi=300,device="tiff",limitsize = FALSE)

  # Read the annotation file for res1.7 dataset
  res1.7_annotation<-fread(file=paste0(ANALYSIS_OUTPUTDIR,"/res1.7 annotation.txt"),data.table=FALSE)

  # Convert the "seurat_clusters" column to a factor
  res1.7_annotation$seurat_clusters<-as.factor(res1.7_annotation$seurat_clusters)

  # Create a data frame for clustering comparison between "RNA" and "AUC" clusters and join with the annotation data
  p<-data.frame(temp@meta.data) %>%
    group_by(seurat_clusters_RNA,seurat_clusters_AUC) %>%
    summarise(N=n()) %>%
    inner_join(y=data.frame(temp@meta.data) %>%
                 group_by(seurat_clusters_RNA) %>%
                 summarise(N_RNA=n()),by="seurat_clusters_RNA") %>%
        inner_join(y=res1.7_annotation,by=c("seurat_clusters_RNA"="seurat_clusters")) %>%
        ggplot(aes(x=seurat_clusters_AUC,y=seurat_clusters_RNA))+

        # Create a heatmap-like plot comparing RNA vs AUC clusters, coloring by the ratio of N/N_RNA
        geom_tile(aes(fill=N/N_RNA),colour="black")+
        geom_text(aes(label=N))+
        scale_fill_gradient(low="white",high="red")+
        theme_classic()+
        facet_grid(CellType~.,scales="free",space="free",switch="y")

  # Save the comparison plot as a TIFF file with a resolution-specific name
  ggsave(plot=p,filename=paste0(FIGURE_OUTPUTDIR,"/UMAP_clustering_RNA_vs_AUC/res",x,"_Clustering_RNA_vs_AUC.tiff"),height=8,width=8,units="cm",dpi=300,device="tiff",limitsize = FALSE)

})

```


### Marker expression
```{r}

# Apply the following operations for each unique value of "Lineage" in temp_feature
sapply(levels(factor(temp_feature$Lineage)),FUN=function(x){

  # Print the current lineage value
  print(x)

  # Set the default assay to "RNA" for seurat_res1.7_AUC
  DefaultAssay(seurat_res1.7_AUC)<-"RNA"

  # Create a violin plot for the genes associated with the current lineage, with AUC clustering information
  tempdata<-VlnPlot(seurat_res1.7_AUC,features=FUN_gene(subset(temp_feature,Lineage==x)$Gene),stack=TRUE,group.by="seurat_clusters_AUC",fill.by="ident",flip=TRUE)$data

  # Modify the 'feature' column to remove the '-E' suffix
  tempdata$feature<-str_split(tempdata$feature,"-E",simplify=TRUE)[,1]

  # Create a ggplot for the violin plot with points for expression data
  p<-ggplot(tempdata,aes(x=ident,y=expression,fill=ident))+
    geom_violin(scale="width",fill=NA,colour="black")+
    geom_point(shape=21,position=position_jitterdodge(jitter.width=1),size=0.5,alpha=0.75,stroke=0)+
    facet_grid(feature~.,scales="free_x",space="free")+
    scale_fill_manual(values=colour_palette)+
    theme_classic()+
    theme(legend.position="left")

  # Save the plot with a file name that includes the current lineage and gene information
  ggsave(plot=p,filename=paste0(FIGURE_OUTPUTDIR,"/Selected markers by AUC/AUC_",x,".tiff"),height=length(subset(temp_feature,Lineage==x)$Gene)*1.7,width=length(levels(factor(tempdata$ident)))*1.5,units="cm",dpi=300,device="tiff",limitsize = FALSE)
})

# Create a UMAP plot with labels and a violin plot for the specified genes, split by Genotype
DimPlot(seurat_res1.7,reduction="umap_harmony",label=TRUE)+VlnPlot(seurat_res1.7,features=FUN_gene(c("SLC12A2","SLC12A5")),split.by="Genotype")

```


### Clustering comparison for res0.4
```{r}
# Create a dataframe from seurat_res1.7_AUC's meta data, group by RNA and AUC clusters, and count the number of occurrences in each group
p<-data.frame(seurat_res1.7_AUC@meta.data) %>%
  group_by(seurat_clusters_RNA,seurat_clusters_AUC) %>%
  summarise(N=n()) %>%

  # Join with data containing RNA cluster counts
  inner_join(y=data.frame(seurat_res1.7_AUC@meta.data) %>%
               group_by(seurat_clusters_RNA) %>%
               summarise(N_RNA=n()),by="seurat_clusters_RNA") %>%
  
  # Filter rows where N is greater than 10
  subset(N>10) %>%

  # Join with annotation data
  inner_join(y=res1.7_annotation,by=c("seurat_clusters_RNA"="seurat_clusters")) %>%

  # Create a heatmap with counts and normalized values
  ggplot(aes(x=seurat_clusters_AUC,y=seurat_clusters_RNA))+
  geom_tile(aes(fill=N/N_RNA),colour="black")+
  geom_text(aes(label=N))+
  scale_fill_gradient(low="white",high="red")+
  theme_classic()+
  facet_grid(CellType~.,scales="free",space="free",switch="y")

# Save the heatmap plot as a TIFF file
ggsave(plot=p,filename=paste0(FIGURE_OUTPUTDIR,"/Clustering_RNA_vs_AUC_filtered.tiff"),height=10,width=10,units="cm",dpi=300,device="tiff",limitsize = FALSE)

# Create UMAP plots for RNA vs AUC clusters in both Harmony and AUC reductions, with different groupings and labels
p<-(DimPlot(seurat_res1.7_AUC,label=TRUE,group.by="seurat_clusters_RNA",reduction="umap_harmony",pt.size=0.25)+scale_colour_tableau("Tableau 10"))+
    (DimPlot(seurat_res1.7_AUC,label=TRUE,group.by="seurat_clusters_AUC",reduction="umap_harmony",pt.size=0.25)+scale_colour_tableau("Tableau 10"))+
    (DimPlot(seurat_res1.7_AUC,label=TRUE,group.by="seurat_clusters_RNA",reduction="umap_AUC",pt.size=0.25)+scale_colour_tableau("Tableau 10"))+
    (DimPlot(seurat_res1.7_AUC,label=TRUE,group.by="seurat_clusters_AUC",reduction="umap_AUC",pt.size=0.25)+scale_colour_tableau("Tableau 10"))

# Save the UMAP clustering plot as a TIFF file
ggsave(plot=p,filename=paste0(FIGURE_OUTPUTDIR,"/UMAP_clustering_RNA_vs_AUC.tiff"),height=16,width=18,units="cm",dpi=300,device="tiff",limitsize = FALSE)

# Create a dataframe from the meta data again, perform similar grouping and joining operations, and store the result in temp
temp<-data.frame(seurat_res1.7_AUC@meta.data) %>%
  group_by(seurat_clusters_RNA,seurat_clusters_AUC) %>%
  summarise(N=n()) %>%
  inner_join(y=data.frame(seurat_res1.7_AUC@meta.data) %>%
               group_by(seurat_clusters_RNA) %>%
               summarise(N_RNA=n()),by="seurat_clusters_RNA")%>%
  inner_join(y=res1.7_annotation,by=c("seurat_clusters_RNA"="seurat_clusters"))

# Write the results to an Excel file
write.xlsx(temp,file=paste0(ANALYSIS_OUTPUTDIR,"/Clustering comparison_RNA_vs_AUC_res0.5.xlsx"))

```



### Heatmap expression
```{r}
# Load annotation data from a file into a data.table and convert 'seurat_clusters' to a factor
res1.7_annotation<-fread(file=paste0(ANALYSIS_OUTPUTDIR,"/res1.7 annotation.txt"),data.table=FALSE)
res1.7_annotation$seurat_clusters<-as.factor(res1.7_annotation$seurat_clusters)

# Define the list of genes and their associated lineage
temp_feature<-data.frame(Gene=c(
  "S100B","GFAP","AQP4","GJA1","GJB6","ALDH1L1",
  "EGFR","SOX9","HES1","CD44","NFIA","FGFR3",
  "ASCL1","DCX","CD24",
  "RBFOX3","SNAP25","STMN2","SYT1","TUBB3",
  "TBR1","SLC17A7","SLC17A6","EOMES",
  "NKX2-1","LHX6","LHX8","SOX6","SATB1","OLIG2","TOX3","PLS3",
  "NR2F2","PROX1","SP8",
  "DLX2","DLX5","NR2F1",
  "BCL11B","NOLZ1","FOXP1","FOXP2","ISL1","PPP1R1B","DRD1","DRD2","PENK","TAC1",
  "GAD1","GAD2","CALB2","CALB1","SLC6A1","GABBR1","GABBR2","DLX6-AS1",
  "RELN","SST","PVALB","VIP","HTR3A","TAC1","CCK","NPY","ERBB4","CXCR4","LAMP5",
  "LMX1A","TH","KCNJ6","SLC18A1","SLC6A3",
  "TTYH1","RFX4","NESTIN","SOX2","PTN","FABP7",
  "HOXA2","PAX2","OTX2","GBX2","FOXG1",
  "PAX3","NKX2-1","NKX2-2","NKX6-1","PAX6","SIX6","SIX3","FOXA2",
  "SOX10","PDGFRA","MBP"),
  Lineage=c(rep("Astro",6),rep("APC",6),rep("NB",3),rep("Neuron",5),
            rep("Glut",4),rep("MGE",8),rep("CGE",3),rep("GE",3),
            rep("LGE",10),rep("GABA",8),rep("IntSub",11),rep("mDA",5),rep("RGL",6),
            rep("R-C",5),rep("D-V",8),rep("ODC",3)))

# Set the default assay to RNA for the object seurat_res1.7_AUC
DefaultAssay(seurat_res1.7_AUC)<-"RNA"

# Get expression data for the genes in temp_feature
expression_matrix<-GetAssayData(seurat_res1.7_AUC[FUN_gene(unique(temp_feature$Gene)),])

# Save rownames and colnames before processing expression data
ROWNAMES_TEMP<-rownames(expression_matrix)
COLNAMES_TEMP<-colnames(expression_matrix)

# Remove columns with no expression (column sums are 0)
expression_matrix<-as.data.table(expression_matrix[,colSums(expression_matrix)>0])

# Modify the gene names to remove "-E" suffixes
expression_matrix$gene<-ROWNAMES_TEMP
expression_matrix$gene<-str_split(expression_matrix$gene,"-E",simplify=TRUE)[,1]

# Melt the expression matrix and join it with feature and metadata information
expression_matrix<-melt(expression_matrix,id.vars="gene") %>%
  full_join(y=temp_feature,by=c("gene"="Gene")) %>%
  left_join(y=seurat_res1.7_AUC@meta.data,by=c("variable"="CellID")) %>%
  left_join(y=res1.7_annotation,by=c("seurat_clusters_RNA"="seurat_clusters"))

# Remove rows with missing values in the expression data
expression_matrix<-expression_matrix[!is.na(expression_matrix$value),]

# Create a heatmap plot using ggplot, showing the scaled expression values of genes across different lineages and clusters
p<-ggplot(data=expression_matrix,
          aes(x=reorder(variable,nCount_RNA),y=gene,fill=scale(value)))+
  geom_raster()+
  scale_fill_gradient(low="white",high="#ae017e")+
  facet_grid(Lineage~seurat_clusters_AUC+seurat_clusters_RNA,scales="free",space="free")+
  labs(y="",x="",fill="")+
  theme_bw()+
  theme(plot.margin=unit(c(0,0,0,0),"cm"),
        axis.text.x=element_blank(),
        legend.position="none",
        legend.title=element_blank(),
        legend.text=element_text(size=8),
        panel.spacing = unit(0.05, "lines"))

# Save the heatmap plot as a TIFF file
ggsave(plot=p,filename=paste0(FIGURE_OUTPUTDIR,"/Key markers_heatmap_AUC clusters.tiff"),units="cm",width=18,height=20,dpi=300)

```

# Integrated clustering
Clustering based on both gene expression and SCENIC
```{r}
# Load the integrated clustering results from an excel file.
integrated_clustering<-read.xlsx(paste0(ANALYSIS_OUTPUTDIR,"/Clustering comparison_RNA_vs_AUC_res0.5.xlsx"))

# Create new seurat clusters by combining RNA and AUC clusters.
seurat_res1.7_AUC$seurat_clusters_new<-paste0(seurat_res1.7_AUC$seurat_clusters_RNA,seurat_res1.7_AUC$seurat_clusters_AUC)

# Map cell type labels from the integrated clustering to the seurat object.
seurat_res1.7_AUC$CellType<-mapvalues(seurat_res1.7_AUC$seurat_clusters_new,from=integrated_clustering$seurat_clusters_new,to=integrated_clustering$CellType)

# Map cell class labels from the integrated clustering to the seurat object.
seurat_res1.7_AUC$CellClass<-mapvalues(seurat_res1.7_AUC$seurat_clusters_new,from=integrated_clustering$seurat_clusters_new,to=integrated_clustering$CellClass)

# Create a new subset of seurat object, excluding cells with CellType "Discard".
seurat_res1.7_AUC_subset<-subset(seurat_res1.7_AUC,CellType!="Discard")


```
## Marker expression
```{r}
# Set the default assay of the Seurat object to "RNA".
DefaultAssay(seurat_res1.7_AUC)<-"RNA"

# Set the identity of the Seurat object to the new seurat clusters.
Idents(seurat_res1.7_AUC)<-"seurat_clusters_new"

# Apply a function over each unique value of "Lineage" in the temp_feature dataset.
sapply(levels(factor(temp_feature$Lineage)),FUN=function(x){
  print(x) # Print the current lineage being processed.
  
  # Generate violin plot data for the genes belonging to the current lineage.
  tempdata<-VlnPlot(seurat_res1.7_AUC,features=FUN_gene(subset(temp_feature,Lineage==x)$Gene),stack=TRUE,fill.by="ident",flip=TRUE)$data
  
  # Clean the feature names to remove "-E" suffix.
  tempdata$feature<-str_split(tempdata$feature,"-E",simplify=TRUE)[,1]
  
  # Join the generated data with the integrated clustering data and filter out discarded cells.
  tempdata<-inner_join(tempdata,integrated_clustering,by=c("ident"="seurat_clusters_new")) %>%
    subset(CellType!="Discard")
    
  # Create a ggplot object with violin plots for the gene expression by cell type and cluster.
  p<-ggplot(tempdata,aes(x=ident,y=expression,fill=CellType))+
    geom_violin(colour="black")+
    # Optionally add jittered points, currently commented out.
    #geom_point(shape=21,position=position_jitterdodge(jitter.width=2,dodge.width=2),size=1,alpha=0.75,stroke=0)+
    facet_grid(feature~CellType,scales="free_x",space="free")+
    scale_fill_tableau()+
    theme_classic()+
    theme(legend.position="left")
    
  # Save the plot as a TIFF file with specific height and width based on the number of genes and clusters.
  ggsave(plot=p,filename=paste0(FIGURE_OUTPUTDIR,"/Selected markers by AUC_reannotated/AUC_",x,".tiff"),height=length(subset(temp_feature,Lineage==x)$Gene)*2+2,width=length(levels(factor(tempdata$seurat_clusters_AUC)))*3+5,units="cm",dpi=300,device="tiff",limitsize = FALSE)
})


```

## Number from each sample
```{r}
# Create a data frame by grouping the meta data of the subset Seurat object by cluster and sample,
# then count the number of cells in each combination of seurat_clusters_new and Sample.
p<-seurat_res1.7_AUC_subset@meta.data %>%
  group_by(seurat_clusters_new,Sample) %>%
  summarise(N=n()) %>%
  
  # Inner join with the total number of cells in each sample.
  inner_join(y=seurat_res1.7_AUC_subset@meta.data %>% group_by(Sample) %>% summarise(NumCell=n()),by="Sample") %>%
  
  # Inner join with the sample metadata.
  inner_join(y=sample_metadata,by="Sample") %>%
  
  # Inner join with the integrated clustering data, excluding cells marked as "Discard".
  inner_join(y=subset(integrated_clustering[,c(1,2,5,6,7,8,9)],CellType!="Discard"),by="seurat_clusters_new") %>%
  
  # Create a ggplot object that visualizes the data as a heatmap.
  ggplot(aes(x=seurat_clusters_new,y=Sample,fill=N/NumCell))+
  
  # Add black borders around each tile.
  geom_tile(colour="black")+
  
  # Add the number of cells in each tile as text labels.
  geom_text(aes(label=N))+
  
  # Set the color scale to go from white to red, based on the ratio of N/NumCell.
  scale_fill_gradient(low="white",high="red")+
  
  # Create facets for each CellLine and seurat_clusters_RNA, with free scales and space.
  facet_grid(CellLine~seurat_clusters_RNA,scales="free",space="free")+
  
  # Apply a classic theme to the plot.
  theme_classic()

```



# Velocyto
## Data preparation
```{r}
# Create a data frame called bam_list, containing Barcode and SampleID columns from the seurat object.
bam_list<-data.frame(Barcode=seurat$Barcode,SampleID=seurat$SampleID)

# Create a new column 'ChipSample' by mapping unique SampleID values to specific chip sample names.
bam_list$ChipSample<-mapvalues(bam_list$SampleID,from=unique(bam_list$SampleID),to=c("S1","S2","S5","S6","S7","S8","S9","S10","S12","S11","S13","S14","S15","S16","S17","S18"))

# Create a new column 'FileLocation' by constructing the full path of the BAM files based on the SampleID and Barcode.
bam_list$FileLocation<-paste0("/scratch/c.c1629716/NGS_December2023/05_Analyze/",bam_list$SampleID,"_",bam_list$ChipSample,"_L001/bam/",bam_list$Barcode,".Aligned.out.bam")

# Create another column 'NewLocation' by constructing a new path for the BAM files.
bam_list$NewLocation<-paste0("/scratch/c.c1629716/NGS_December2023/velocyto/",bam_list$SampleID,"_",bam_list$Barcode,".Aligned.out.bam")

# Write the bam_list data frame to a CSV file in the project directory.
fwrite(bam_list,file=paste0(PROJECT_DIR,"/bam_list.csv"))

# Use mclapply to copy the BAM files from the 'FileLocation' to the 'NewLocation' in parallel with 16 cores.
mclapply(1:nrow(bam_list),mc.cores=16,FUN=function(i){
  file.copy(from=bam_list$FileLocation[i],
            to=bam_list$NewLocation[i])
})

```

## RNA velocity

## Seurat analysis
```{r}
# Load the filtered velocyto output data for neurons from an RDS file.
velocyto_output_neuron_filtered<-readRDS(paste0(SAVE_DIR,"/velocyto_output_neuron_filtered.RDS"))

# Load the filtered velocity estimates for neurons from an RDS file.
velocity_estimate_neuron_filtered<-readRDS(paste0(SAVE_DIR,"/velocity_estimate_neuron_filtered.RDS"))

# Create a new assay object called "spliced" in the Seurat object, using the spliced counts from the velocyto data.
seurat_res1.7[["spliced"]]<-CreateAssayObject(counts=velocyto_output_neuron_filtered$spliced[,colnames(velocyto_output_neuron_filtered$spliced) %in% colnames(seurat_res1.7)])

# Create a new assay object called "unspliced" in the Seurat object, using the unspliced counts from the velocyto data.
seurat_res1.7[["unspliced"]]<-CreateAssayObject(counts=velocyto_output_neuron_filtered$unspliced[,colnames(velocyto_output_neuron_filtered$unspliced) %in% colnames(seurat_res1.7)])

```

## Data preparation
```{r}
# Load the Matrix library from a custom location on the local machine.
library(Matrix,lib.loc="C:/Users/Zongze Li/Documents/R/win-library/Custom")

# Load the velociraptor library from a specified location.
library(velociraptor,lib.loc=LIBLOC)

# Set the default assay for the Seurat object to "RNA".
DefaultAssay(seurat_res1.7)<-"RNA"

# Create a SingleCellExperiment object for velocity analysis using spliced and unspliced counts from the Seurat object.
sce_res1.7_velocity<-SingleCellExperiment(assay=list(spliced=GetAssayData(seurat_res1.7,assay="spliced",layer="counts"),unspliced=GetAssayData(seurat_res1.7,assay="unspliced",layer="counts")),colData=seurat_res1.7@meta.data)

# Normalize the SingleCellExperiment object (velocity data) using log-normalization for the spliced and unspliced assays.
sce_res1.7_velocity<-logNormCounts(sce_res1.7_velocity,assay.type=1)

# Get the highly variable genes (HVGs) from the Seurat object.
seurat_res1.7_hvg<-VariableFeatures(seurat_res1.7)

# Save the list of highly variable genes to an RData file.
save(seurat_res1.7_hvg,file=paste0(SAVE_DIR,"/seurat_res1.7_hvg.RData"))

# Perform scvelo analysis on the spliced counts, using the list of highly variable genes.
velo.out<-scvelo(sce_res1.7_velocity,subset.row=seurat_res1.7_hvg,assay.X="spliced")

# Run PCA on the SingleCellExperiment object using the highly variable genes.
sce_res1.7_velocity <- runPCA(sce_res1.7_velocity, subset_row=seurat_res1.7_hvg)

# Run UMAP on the SingleCellExperiment object using the PCA results.
sce_res1.7_velocity <- runUMAP(sce_res1.7_velocity, dimred="PCA")

# Save the velocity output object and the updated SingleCellExperiment object to RData files.
save(velo.out,file=paste0(SAVE_DIR,"/velo.out.RData"))
save(sce_res1.7_velocity,file=paste0(SAVE_DIR,"/sce_res1.7_velocity.RData"))

# Add the calculated velocity pseudotime to the Seurat object.
seurat_res1.7$velocity_pseudotime<-velo.out$velocity_pseudotime

# Set the UMAP coordinates in the velocity object to match the ones from the Seurat object.
sce_res1.7_velocity@int_colData@listData[["reducedDims"]]@listData[["UMAP"]]<-seurat_res1.7@reductions[["umap_harmony"]]@cell.embeddings

# Embed the velocity vectors using UMAP coordinates.
embedded <- embedVelocity(reducedDim(sce_res1.7_velocity, "UMAP"), velo.out)

# Generate a grid of velocity vectors to visualize the flow of cells.
grid.df <- gridVectors(sce_res1.7_velocity, embedded, use.dimred = "UMAP",resolution=20)

# Create a UMAP plot showing the velocity pseudotime, with arrows indicating the direction of velocity.
p<-FeaturePlot(seurat_res1.7,"velocity_pseudotime",reduction="umap_harmony",pt.size=0.5)+geom_segment(data=grid.df,aes(x=start.1,y=start.2,xend=end.1,yend=end.2,colour=NULL),arrow=arrow(length=unit(0.05, "inches")))+scale_colour_gradient2_tableau()

# Save the UMAP plot with velocity vectors as a TIFF image.
ggsave(plot=p,filename=paste0(FIGURE_OUTPUTDIR,"/RNA velocity trajectory/pseudotime_UMAP.tiff"),units="cm",width=10,height=8,dpi=300)

# Create a density plot for the velocity pseudotime, grouped by genotype and annotated by cell types.
p<-ggplot(data=seurat_res1.7@meta.data,
          aes(x=velocity_pseudotime))+
    geom_density(linewidth=0.5,aes(colour=Genotype))+
    scale_colour_colorblind()+
    scale_linetype_manual(values=c("solid","dashed","dotted"))+
    facet_wrap(.~Annotation,scales="free_y",ncol=1)+
    theme_classic()

# Save the density plot as a TIFF image.
ggsave(plot=p,filename=paste0(FIGURE_OUTPUTDIR,"/RNA velocity trajectory/CellDensity.tiff"),units="cm",width=8,height=12,dpi=300)

```


# Maturity comparison
## Shi projection
```{r}
# Load the Seurat object from a saved RData file located in the specified OneDrive path.
load(file=paste0(Sys.getenv("ONEDRIVE"),"/Postdoc\\Project\\RNAseq\\External\\Shi 34882453\\Saved RData/seurat_shi.RData"))

# Create a temporary copy of the Seurat object.
seurat_temp<-seurat_res1.7

# Set the default assay for the Seurat object to "RNA".
DefaultAssay(seurat_temp)<-"RNA"

# Ensure unique row names in the Seurat object by modifying the gene identifiers.
rownames(seurat_temp)<-make.unique(FUN_geneid(rownames(seurat_temp)))

# Perform reference mapping of the query Seurat object (seurat_temp) against the reference (seurat_shi) with specific parameters.
seurat_res1.7_Shi<-FUN_seurat_reference_mapping(
  query=seurat_temp,  # Query Seurat object
  reference=subset(seurat_shi,Major.types!="Microglia" & Major.types!= "Endothelial" & Major.types!= "OPC"),  # Subset of the reference excluding specific cell types
  IdentVariable="CellType",  # The variable to use for identity class in the reference
  k.weight=50,  # k-nearest neighbor weight
  dims=1:30,  # PCA dimensions used for the mapping
  prefix="Reference mapping/Predict_Shi",  # Prefix for output files
  mapped.query=NULL,  # Optional pre-mapped query
  plot.only=FALSE,  # Don't plot only
  reference.exclusion=NULL,  # No reference exclusions
  reference.assay="RNA",  # Assay used in the reference
  query.assay="RNA",  # Assay used in the query
  reference.reduction="harmony"  # Reduction used for reference mapping
)

# Create a heatmap showing the predicted cell type distribution across Seurat clusters based on reference mapping.
p<-seurat_res1.7_Shi@meta.data %>% 
  group_by(seurat_clusters,predicted.id) %>%  # Group by Seurat clusters and predicted cell types
  summarise(N=n()) %>%  # Count the number of cells in each group
  inner_join(y=seurat_res1.7_Shi@meta.data %>% 
               group_by(seurat_clusters) %>%  # Group by Seurat clusters to get total cell count
               summarise(Num=n()),  # Count total cells in each Seurat cluster
             by="seurat_clusters") %>%
  ggplot(aes(x=seurat_clusters,y=predicted.id,fill=N/Num*100)) +  # Create a ggplot for heatmap
  geom_tile(colour="black") +  # Add tiles to the heatmap
  scale_fill_gradient(low="grey",high="red") +  # Color gradient for fill
  labs(y="predicted.id",x="seurat_clusters",fill="Percent of cells (%)") +  # Labels for the axes and fill legend
  theme_classic() +  # Use a classic theme for the plot
  theme(legend.position="bottom")  # Place the legend at the bottom

# Save the heatmap as a TIFF image to the specified output directory.
ggsave(plot=p,filename=paste0(FIGURE_OUTPUTDIR,"/Presentation/Prediction heatmap shi.tiff"),height=8,width=10,units="cm",dpi=300,device="tiff",limitsize = FALSE)

```


## yu projection
```{r}
# Load the Seurat object from a saved RData file located in the specified OneDrive path.
load(file=paste0(Sys.getenv("ONEDRIVE"),"/Postdoc\\Project\\RNAseq\\External\\yu 34882453\\Saved RData/seurat_yu.RData"))

# Create a temporary copy of the Seurat object.
seurat_temp<-seurat_res1.7

# Set the default assay for the Seurat object to "RNA".
DefaultAssay(seurat_temp)<-"RNA"

# Ensure unique row names in the Seurat object by modifying the gene identifiers.
rownames(seurat_temp)<-make.unique(FUN_geneid(rownames(seurat_temp)))

# Perform reference mapping of the query Seurat object (seurat_temp) against the reference (seurat_yu) with specific parameters.
seurat_res1.7_yu<-FUN_seurat_reference_mapping(
  query=seurat_temp,  # Query Seurat object
  reference=subset(seurat_yu,CellType!="Microglia" & CellType!= "Endothelial" & CellType!= "OPC"),  # Subset of the reference excluding specific cell types
  IdentVariable="CellType",  # The variable to use for identity class in the reference
  k.weight=50,  # k-nearest neighbor weight
  dims=1:30,  # PCA dimensions used for the mapping
  prefix="Reference mapping/Predict_yu",  # Prefix for output files
  mapped.query=NULL,  # Optional pre-mapped query
  plot.only=FALSE,  # Don't plot only
  reference.exclusion=NULL,  # No reference exclusions
  reference.assay="RNA",  # Assay used in the reference
  query.assay="RNA",  # Assay used in the query
  reference.reduction="harmony"  # Reduction used for reference mapping
)

# Create a heatmap showing the predicted cell type distribution across Seurat clusters based on reference mapping.
p<-seurat_res1.7_yu@meta.data %>% 
  group_by(seurat_clusters,predicted.id) %>%  # Group by Seurat clusters and predicted cell types
  summarise(N=n()) %>%  # Count the number of cells in each group
  inner_join(y=seurat_res1.7_yu@meta.data %>% 
               group_by(seurat_clusters) %>%  # Group by Seurat clusters to get total cell count
               summarise(Num=n()),  # Count total cells in each Seurat cluster
             by="seurat_clusters") %>%
  ggplot(aes(x=seurat_clusters,y=predicted.id,fill=N/Num*100)) +  # Create a ggplot for heatmap
  geom_tile(colour="black") +  # Add tiles to the heatmap
  scale_fill_gradient(low="grey",high="red") +  # Color gradient for fill
  labs(y="predicted.id",x="seurat_clusters",fill="Percent of cells (%)") +  # Labels for the axes and fill legend
  theme_classic() +  # Use a classic theme for the plot
  theme(legend.position="bottom")  # Place the legend at the bottom

# Save the heatmap as a TIFF image to the specified output directory.
ggsave(plot=p,filename=paste0(FIGURE_OUTPUTDIR,"/Presentation/Prediction heatmap yu.tiff"),height=8,width=10,units="cm",dpi=300,device="tiff",limitsize = FALSE)

```

## Allison projection
```{r}
# Load the Seurat object from a saved RData file located in the specified OneDrive path.
load(file=paste0(Sys.getenv("ONEDRIVE"),"/Postdoc\\Project\\RNAseq\\External\\Allison 34506726\\Saved RData/seurat_allison.RData"))

# Create a temporary copy of the Seurat object.
seurat_temp<-seurat_res1.7

# Ensure unique row names in the Seurat object by modifying the gene identifiers.
rownames(seurat_temp)<-make.unique(FUN_geneid(rownames(seurat_temp)))

# Perform reference mapping of the query Seurat object (seurat_temp) against the reference (seurat_allison) with specific parameters.
seurat_res1.7_allison<-FUN_seurat_reference_mapping(
  query=seurat_temp,  # Query Seurat object
  reference=seurat_allison,  # Reference Seurat object
  IdentVariable="seurat_clusters",  # The variable to use for identity class in the reference
  k.weight=50,  # k-nearest neighbor weight
  dims=1:30,  # PCA dimensions used for the mapping
  prefix="Reference mapping/Predict_Allison",  # Prefix for output files
  mapped.query=NULL,  # Optional pre-mapped query
  plot.only=FALSE,  # Don't plot only
  reference.exclusion=NULL,  # No reference exclusions
  reference.assay="RNA",  # Assay used in the reference
  query.assay="RNA",  # Assay used in the query
  reference.reduction="pca"  # Reduction used for reference mapping
)

```




## Shi-pseudotime
```{r}
#seurat_shi_MGE<-DietSeurat(subset(seurat_shi,seurat_clusters%in%c(0,6,11,21,9,2,13,14,15,24,8,19,23,27,22,28)))
#seurat_shi_MGE<-seurat_shi_MGE[rowSums(seurat_shi_MGE)>=5,]

#seurat_shi_MGE<-seurat_shi_MGE %>%
  #NormalizeData(scale.factor=1e4) %>% 
  #FindVariableFeatures() %>%
  #ScaleData(vars.to.regress=c("nCount_RNA","percent.mt")) %>% 
  #RunPCA()

#seurat_shi_MGE<-RunHarmony(seurat_shi_MGE,dims=dims.chosen,plot_convergence=FALSE,group.by.vars="Individual")
#seurat_shi_MGE<-RunUMAP(seurat_shi_MGE,dims=1:30,n.neighbors=30,min.dist=0.3,reduction="harmony")

#DimPlot(seurat_shi_MGE,group.by="seurat_clusters")+scale_colour_tableau()

monocle_shi <- as.cell_data_set(seurat_shi)
rowData(monocle_shi)$gene_name<-rownames(monocle_shi)
rowData(monocle_shi)$gene_short_name<-rowData(monocle_shi)$gene_name
monocle_shi <- cluster_cells(monocle_shi)
monocle_shi <- learn_graph(monocle_shi,close_loop=FALSE)
plot_cells(monocle_shi, color_cells_by="seurat_clusters",cell_size = 0.5)+theme(legend.position = "bottom")
plot_cells(monocle_shi,genes="MKI67",cell_size = 0.5)+theme(legend.position = "bottom")
plot_cells(monocle_shi,color_cells_by=("Major.types"),cell_size = 0.5)+theme(legend.position = "bottom")
plot_cells(monocle_shi,cell_size = 0.5)+theme(legend.position = "bottom")
```



# Combined analysis of Allison
## Harmony workflow
```{r}
load(file=paste0(Sys.getenv("ONEDRIVE"),"/Postdoc\\Project\\RNAseq\\External\\Allison 34506726\\Saved RData/seurat_allison.RData"))

seurat_temp<-seurat_res1.7
rownames(seurat_temp)<-make.unique(FUN_geneid(rownames(seurat_temp)))
seurat_temp$Batch<-"This"
seurat_temp$seurat_clusters_original<-paste0("This_",seurat_temp$seurat_clusters)
seurat_allison$seurat_clusters_original<-paste0("Allison_",seurat_allison$seurat_clusters)

seurat_allison_res1.7<-merge(DietSeurat(seurat_temp),DietSeurat(seurat_allison))

seurat_allison_res1.7<-seurat_allison_res1.7 %>% 
  NormalizeData(scale.factor=1e4) %>% 
  FindVariableFeatures() %>%
  ScaleData(vars.to.regress=c("nCount_RNA","percent.mt")) %>% 
  RunPCA(npcs=80)

p<-ElbowPlot(seurat_allison_res1.7,ndims=80)+theme_classic()
ggsave(plot=p,filename=paste0(FIGURE_OUTPUTDIR,"/MergedAllison/ElbowPlot.tiff"),width=10,height=8,units="cm",dpi=300,device="tiff",limitsize = TRUE)

# Jackstraw method
seurat_allison_res1.7 <- JackStraw(seurat_allison_res1.7, num.replicate = 100,dims=80)
seurat_allison_res1.7 <- ScoreJackStraw(seurat_allison_res1.7, dims = 1:80)
p<-JackStrawPlot(seurat_allison_res1.7, dims = 1:50)+theme(legend.position="bottom",text=element_text(size=10),plot.background=element_rect(fill="white"))+labs(colour="PC:\nvalue")+guides(colour=guide_legend(ncol=4))
ggsave(plot=p,filename=paste0(FIGURE_OUTPUTDIR,"/MergedAllison/JackStrawPlot.tiff"),width=16,height=14,units="cm",dpi=300,device="tiff",limitsize = TRUE)

dims.chosen<-1:37
seurat_allison_res1.7<-RunUMAP(seurat_allison_res1.7,dims=dims.chosen,reduction.name="umap_pca",reduction="pca")
seurat_allison_res1.7<-RunHarmony(seurat_allison_res1.7,dims=dims.chosen,group.by.vars="Batch") %>%
  RunUMAP(dims=dims.chosen,reduction.name="umap",reduction="harmony")


### Reduction Plots
META_VARIABLE<-c("Batch","seurat_clusters_original")

lapply(META_VARIABLE,FUN=function(x){
  p<-DimPlot(object=seurat_allison_res1.7,reduction="umap_pca",group.by=x,shuffle=TRUE,pt.size=0.25,alpha=0.5)+
    scale_colour_tableau("Tableau 20")+
    theme_classic()+
    theme(legend.position="bottom",
          text=element_text(size=8))+
    guides(colour=guide_legend(nrow=3,override.aes = list(size=1,alpha=1)))
  ggsave(plot=p,filename=paste0(FIGURE_OUTPUTDIR,"/MergedAllison/UMAP_PCA_by",x,".tiff"),width=12,height=10,units="cm",dpi=300,device="tiff",limitsize = TRUE)})

lapply(META_VARIABLE,FUN=function(x){
  p<-DimPlot(object=seurat_allison_res1.7,reduction="umap",group.by=x,shuffle=TRUE,pt.size=0.25,alpha=0.5)+
    scale_colour_tableau("Tableau 20")+
    theme_classic()+
    theme(legend.position="bottom",
          text=element_text(size=8))+
    guides(colour=guide_legend(nrow=3,override.aes = list(size=1,alpha=1)))
  ggsave(plot=p,filename=paste0(FIGURE_OUTPUTDIR,"/MergedAllison/UMAP_Harmony_by",x,".tiff"),width=12,height=10,units="cm",dpi=300,device="tiff",limitsize = TRUE)})

```

## Seurat workflow
```{r}
seurat_allison_res1.7 <- IntegrateLayers(object = seurat_allison_res1.7, method = CCAIntegration,orig.reduction = "pca", new.reduction = "integrated.cca")
seurat_allison_res1.7 <- IntegrateLayers(object = seurat_allison_res1.7, method = RPCAIntegration,orig.reduction = "pca", new.reduction = "integrated.rpca")
seurat_allison_res1.7 <- IntegrateLayers(object = seurat_allison_res1.7, method = HarmonyIntegration,orig.reduction = "pca", new.reduction = "harmony")
seurat_allison_res1.7 <- IntegrateLayers(object = seurat_allison_res1.7, method = FastMNNIntegration,orig.reduction = "pca", new.reduction = "integrated.mnn")


seurat_allison_res1.7<-seurat_allison_res1.7 %>%
  RunUMAP(reduction = "integrated.cca", dims = 1:30, reduction.name = "umap_cca") %>%
  RunUMAP(reduction = "integrated.rpca", dims = 1:30, reduction.name = "umap_rpca") %>%
  RunUMAP(reduction = "integrated.mnn", dims = 1:30, reduction.name = "umap_mnn")

temp<-sample(colour_palette,20)
p<-(DimPlot(seurat_allison_res1.7,reduction="umap_pca",group.by="seurat_clusters_original",label=FALSE)+scale_colour_manual(values=temp))+
  (DimPlot(seurat_allison_res1.7,reduction="umap",group.by="seurat_clusters_original",label=FALSE)+scale_colour_manual(values=temp))+
  (DimPlot(seurat_allison_res1.7,reduction="umap_cca",group.by="seurat_clusters_original",label=FALSE)+scale_colour_manual(values=temp))+
  (DimPlot(seurat_allison_res1.7,reduction="umap_rpca",group.by="seurat_clusters_original",label=FALSE)+scale_colour_manual(values=temp))+
  (DimPlot(seurat_allison_res1.7,reduction="umap_mnn",group.by="seurat_clusters_original",label=FALSE)+scale_colour_manual(values=temp))
ggsave(plot=p,filename=paste0(FIGURE_OUTPUTDIR,"/MergedAllison/Integration testing.tiff"),width=30,height=20,units="cm",dpi=300,device="tiff",limitsize = FALSE)

seurat_allison_res1.7 <- JoinLayers(seurat_allison_res1.7)
```
DimPlot(seurat_allison_res1.7,group.by="seurat_clusters_original",reduction="umap",label=T)
## Projection to Shi
```{r}
load(file=paste0(Sys.getenv("ONEDRIVE"),"/Postdoc\\Project\\RNAseq\\External\\Shi 34882453\\Saved RData/seurat_shi.RData"))

seurat_temp<-seurat_allison_res1.7
seurat_temp$seurat_clusters<-seurat_temp$seurat_clusters_original

seurat_allison_res1.7_Shi<-FUN_seurat_reference_mapping(
  query=seurat_temp,
  reference=subset(seurat_shi,Major.types!="Microglia" & Major.types!= "Endothelial" & Major.types!= "OPC"),
  IdentVariable="CellType",k.weight=50,dims=1:30,
  prefix="Reference mapping/Predict_MergedAllison_Shi",
  mapped.query=NULL,plot.only=FALSE,reference.exclusion=NULL,
  reference.assay="RNA",query.assay="RNA",reference.reduction="harmony")


p<-seurat_allison_res1.7_Shi@meta.data %>% 
  group_by(seurat_clusters_original,predicted.id) %>% 
  summarise(N=n()) %>% 
  inner_join(y=seurat_allison_res1.7_Shi@meta.data %>% 
               group_by(seurat_clusters_original) %>% 
               summarise(Num=n()),
             by="seurat_clusters_original") %>%
  mutate(seurat_clusters_original=str_remove(str_remove(seurat_clusters_original,"llison_"),"his_")) %>%
  ggplot(aes(x=seurat_clusters_original,y=predicted.id,fill=N/Num*100))+
  geom_tile(colour="black")+
  scale_fill_gradient(low="grey",high="red")+
  labs(y="prediced.id",x="seurat_clusters",fill="Percent of cells (%)")+
  theme_classic()+
  theme(legend.position="bottom")
ggsave(plot=p,filename=paste0(FIGURE_OUTPUTDIR,"/Presentation/Allison res1.7 Prediction heatmap shi.tiff"),height=10,width=11,units="cm",dpi=300,device="tiff",limitsize = FALSE)
```


## Projection to yu
```{r}
load("C:/Users/lizon/OneDrive - Cardiff University/Postdoc/Project/RNAseq/External/Yu 34737447/Saved RData/seurat_yu.RData")

seurat_temp<-seurat_allison_res1.7
seurat_temp$seurat_clusters<-seurat_temp$seurat_clusters_original
#rownames(seurat_temp)<-make.unique(FUN_geneid(rownames(seurat_temp)))

seurat_allison_res1.7_yu<-FUN_seurat_reference_mapping(query=seurat_temp,
                                                    reference=subset(seurat_yu,CellType!="Microglia" & 
                                                                       CellType!= "Endothelial" & 
                                                                       CellType!= "OPC"),
                                                    IdentVariable="CellType",k.weight=50,dims=1:30,
                                                    prefix="Reference mapping/Predict_MergedAllison_yu",
                                                    mapped.query=NULL,plot.only=FALSE,reference.exclusion=NULL,
                                                    reference.assay="RNA",query.assay="RNA",reference.reduction="harmony")



p<-seurat_allison_res1.7_yu@meta.data %>% 
  group_by(seurat_clusters_original,predicted.id) %>% 
  summarise(N=n()) %>% 
  inner_join(y=seurat_allison_res1.7_yu@meta.data %>% 
               group_by(seurat_clusters_original) %>% 
               summarise(Num=n()),
             by="seurat_clusters_original") %>%
  mutate(seurat_clusters_original=str_remove(str_remove(seurat_clusters_original,"llison_"),"his_")) %>%
  ggplot(aes(x=seurat_clusters_original,y=predicted.id,fill=N/Num*100))+
  geom_tile(colour="black")+
  scale_fill_gradient(low="grey",high="red")+
  labs(y="prediced.id",x="seurat_clusters",fill="Percent of cells (%)")+
  theme_classic()+
  theme(legend.position="bottom")
ggsave(plot=p,filename=paste0(FIGURE_OUTPUTDIR,"/Presentation/Allison res1.7 Prediction heatmap yu.tiff"),height=10,width=11,units="cm",dpi=300,device="tiff",limitsize = FALSE)
```

## Projection to Mayer branch
```{r}
load("C:/Users/lizon/OneDrive - Cardiff University/Postdoc/Project/RNAseq/External/Mayer 29513653/Saved RData/seurat_mayer_subset_branch.RData")

seurat_temp<-seurat_allison_res1.7
seurat_temp$seurat_clusters<-seurat_temp$seurat_clusters_original
#rownames(seurat_temp)<-make.unique(FUN_geneid(rownames(seurat_temp)))

seurat_allison_res1.7_mayerbranch<-FUN_seurat_reference_mapping(query=seurat_temp,
                                                    reference=seurat_mayer_subset_branch,
                                                    IdentVariable="branch",k.weight=30,dims=1:30,
                                                    prefix="Reference mapping/Predict_MergedAllison_Mayerbranch",
                                                    mapped.query=NULL,plot.only=FALSE,reference.exclusion=NULL,
                                                    reference.assay="RNA",query.assay="RNA",
                                                    reference.reduction="harmony")



p<-seurat_allison_res1.7_mayerbranch@meta.data %>% 
  group_by(seurat_clusters_original,predicted.id) %>% 
  summarise(N=n()) %>% 
  inner_join(y=seurat_allison_res1.7_mayerbranch@meta.data %>% 
               group_by(seurat_clusters_original) %>% 
               summarise(Num=n()),
             by="seurat_clusters_original") %>%
  mutate(seurat_clusters_original=str_remove(str_remove(seurat_clusters_original,"llison_"),"his_")) %>%
  ggplot(aes(x=seurat_clusters_original,y=predicted.id,fill=N/Num*100))+
  geom_tile(colour="black")+
  scale_fill_gradient(low="grey",high="red")+
  labs(y="prediced.id",x="seurat_clusters",fill="Percent of cells (%)")+
  theme_classic()+
  theme(legend.position="bottom")
ggsave(plot=p,filename=paste0(FIGURE_OUTPUTDIR,"/Presentation/Allison res1.7 Prediction heatmap Mayer branch.tiff"),height=10,width=11,units="cm",dpi=300,device="tiff",limitsize = FALSE)
```
# Monocle
## Monocle pseudotime
```{r}
library(SeuratWrappers)
seurat_pseudotime<-DietSeurat(seurat_allison_res1.7,assays="RNA",dimreducs=c("pca","harmony","umap"))
  
DimPlot(seurat_pseudotime,reduction="umap")

monocle_res1.7 <- as.cell_data_set(seurat_pseudotime)
rowData(monocle_res1.7)$gene_name<-rownames(monocle_res1.7)
rowData(monocle_res1.7)$gene_short_name<-rowData(monocle_res1.7)$gene_name

#monocle_BP_processed<-preprocess_cds(monocle_BP,num_dim = 50,norm_method="none",use_genes=integration.features)
#monocle_BP_processed<-align_cds(monocle_BP_processed,alignment_group="Batch")
#monocle_BP_processed<-reduce_dimension(monocle_BP_processed,reduction_method="UMAP",preprocess_method="PCA")

monocle_res1.7 <- cluster_cells(monocle_res1.7)
monocle_res1.7 <- learn_graph(monocle_res1.7,close_loop=FALSE,learn_graph_control=list(minimal_branch_len=5))
plot_cells(monocle_res1.7, color_cells_by="seurat_clusters",cell_size = 1)+theme(legend.position = "bottom")+scale_colour_manual(values=temp)
plot_cells(monocle_res1.7, color_cells_by="Phase",cell_size = 1)+theme(legend.position = "bottom")+scale_colour_manual(values=temp)
plot_cells(monocle_res1.7,genes=c("MKI67","SNAP25"),cell_size = 1)+theme(legend.position = "bottom")
plot_cells(monocle_res1.7,cell_size = 1)+theme(legend.position = "bottom")

monocle_res1.7 <- order_cells(monocle_res1.7)

plot_cells(monocle_res1.7,color_cells_by="pseudotime",cell_size = 1)+theme(legend.position = "bottom")

seurat_allison_res1.7$monocle_pseudotime<-pseudotime(monocle_processed)


p<-plot_cells(monocle_res1.7, color_cells_by="seurat_clusters",cell_size = 0.5,show_trajectory_graph = TRUE)+theme(legend.position = "right",legend.margin=unit(x=c(0,0,0,0),units="mm"), text=element_text(size=12))+scale_colour_manual(values=temp)
ggsave(plot=p,filename=paste0(FIGURE_OUTPUTDIR,"/Monocle/UMAP_seurat_clusters.tiff"),width=12,height=10,units="cm",dpi=600)

#p<-plot_cells(monocle_res1.7, color_cells_by="velocity_pseudotime",cell_size = 0.5,show_trajectory_graph = TRUE)+theme(legend.position = "bottom",legend.margin=unit(x=c(0,0,0,0),units="mm"), text=element_text(size=12))
#ggsave(plot=p,filename=paste0(FIGURE_OUTPUTDIR,"/Monocle/UMAP_velocity_pseudotime.tiff"),width=8.5,height=8,units="cm",dpi=600)

p<-plot_cells(monocle_res1.7, color_cells_by="pseudotime",cell_size = 0.5,show_trajectory_graph = TRUE)+theme(legend.position = "bottom",legend.margin=unit(x=c(0,0,0,0),units="mm"), text=element_text(size=12))
ggsave(plot=p,filename=paste0(FIGURE_OUTPUTDIR,"/Monocle/UMAP_pseudotime.tiff"),width=8.5,height=8,units="cm",dpi=600)

p<-plot_cells(monocle_res1.7, color_cells_by="Batch",cell_size = 0.5,show_trajectory_graph = TRUE)+theme(legend.position = "bottom",legend.margin=unit(x=c(0,0,0,0),units="mm"), text=element_text(size=12))+scale_colour_manual(values=temp)
ggsave(plot=p,filename=paste0(FIGURE_OUTPUTDIR,"/Monocle/UMAP_SampleGroup.tiff"),width=8.5,height=8,units="cm",dpi=600)

p<-plot_cells(monocle_res1.7,genes=(c("MKI67","TOP2A","SNAP25","RBFOX3","CD44","ASCL1")),cell_size = 0.5,show_trajectory_graph = TRUE)+theme(legend.position = "bottom",legend.margin=unit(x=c(0,0,0,0),units="mm"), text=element_text(size=12))
ggsave(plot=p,filename=paste0(FIGURE_OUTPUTDIR,"/Monocle/UMAP_proliferation marker.tiff"),width=17,height=15,units="cm",dpi=600)


p<-ggplot(data=seurat_allison_res1.7@meta.data,
          aes(x=monocle_pseudotime))+
  geom_histogram(linewidth=0.5,aes(fill=seurat_clusters_original))+
  scale_fill_manual(values=colour_palette)+
  scale_linetype_manual(values=c("solid","dashed","dotted"))+
  #facet_wrap(.~seurat_clusters)+
  theme_classic()
ggsave(plot=p,filename=paste0(FIGURE_OUTPUTDIR,"/Monocle/CellDensity.tiff"),units="cm",width=13,height=8,dpi=300)


p<-ggplot
```

## Monocle DEG
``` {r}
monocle_processed<-preprocess_cds(monocle_res1.7,num_dim=50,use_genes=VariableFeatures(seurat_allison_res1.7))
#monocle_processed@reduce_dim_aux@listData[["PCA"]]@listData[["model"]]@listData[["svd_v"]]<-seurat_allison_res1.7@reductions[["harmony"]]@feature.loadings
#monocle_processed@reduce_dim_aux@listData[["PCA"]]@listData[["model"]]@listData[["svd_sdev"]]<-seurat_allison_res1.7@reductions[["harmony"]]@stdev

pr_test_res <- graph_test(monocle_processed, neighbor_graph="principal_graph")
pr_deg_ids <- row.names(subset(pr_test_res, q_value < 0.05))

gene_module_df <- find_gene_modules(monocle_processed[pr_deg_ids,], resolution=1e-3)

names(gene_module_df)[1]<-"hgnc_symbol"


cell_group_df <- tibble::tibble(cell=row.names(colData(monocle_processed)),cell_group=colData(monocle_processed)$seurat_clusters)
agg_mat <- aggregate_gene_expression(monocle_processed, gene_module_df, cell_group_df)
row.names(agg_mat) <- stringr::str_c("Module ", row.names(agg_mat))
p<-pheatmap::pheatmap(agg_mat,scale="column", clustering_method="ward.D2")
ggsave(plot=p,filename=paste0(FIGURE_OUTPUTDIR,"/Monocle/Gene module_heatmap.tiff"),width=17,height=9,units="cm",dpi=600)

write.xlsx(gene_module_df,file=paste0(ANALYSIS_OUTPUTDIR,"/DEG/Monocle_MergedAllison_Gene modules.xlsx"))

agg_mat<-as.data.frame(agg_mat)
agg_mat$module<-str_remove(rownames(agg_mat),"Module ")
agg_mat$max.cluster<-sapply(1:nrow(agg_mat),FUN=function(i){
  paste0("Cluster ",names(agg_mat)[which(agg_mat[i,1:3]==max(agg_mat[i,1:3]))])
})


# Gene expression on UMAP - this needs to be run in R4.2.0

tiff(filename=paste0(FIGURE_OUTPUTDIR,"/Monocle/UMAP_gene module_expression.tiff"),width=12,height=8,units="cm",res=600)
plot_cells(monocle_processed,genes=gene_module_df,label_cell_groups=TRUE,show_trajectory_graph=TRUE,cell_size=1)+scale_colour_gradient(low="grey",high="red")+theme(legend.position="right")
dev.off()

# Geneset enrichment

query_temp<-lapply(unique(gene_module_df$module),FUN=function(x){(subset(gene_module_df,module==x)$hgnc_symbol)})
names(query_temp)<-unique(gene_module_df$module)
GO_MonocleModules<-FUN_Geneset_Overlap(query=query_temp,universe=(rownames(seurat_allison_res1.7)),prefix="MergedAllison_MonocleModules",OrgDb=org.Hs.eg.db,ont="All",keyType="SYMBOL",minGSSize=50,maxGSSize=500,nGO=10,pAdjustMethod="BH",pvalueCutoff=0.01,qvalueCutoff=0.05,pthreshold=0.05)
```


# WGCNA
```{r}
enableWGCNAThreads(nThreads = 24)

seurat_temp<-seurat_res1.7
rownames(seurat_temp)<-make.unique(FUN_geneid(rownames(seurat_temp)))

seurat_res1.7_wgcna<-SetupForWGCNA(subset(seurat_res1.7,seurat_clusters%in%c(0,1,2,3,4)),gene_select = "fraction",fraction = 0.05, wgcna_name = "res1.7")

seurat_res1.7_wgcna@meta.data%>%group_by(seurat_clusters,Genotype)%>%summarise(n())
seurat_res1.7_wgcna <- MetacellsByGroups(seurat_obj = seurat_res1.7_wgcna,group.by = c("seurat_clusters", "Genotype","Sample"),reduction = 'harmony',k = 10,max_shared = 10,ident.group = 'seurat_clusters',min_cells=10)

seurat_res1.7_wgcna <- NormalizeMetacells(seurat_res1.7_wgcna) %>%
  ScaleMetacells(features=VariableFeatures(seurat_res1.7_wgcna))
  # %>% RunPCAMetacells(features=VariableFeatures(seurat_res1.7_wgcna)) %>%
  #RunHarmonyMetacells(group.by.vars="CellLine") %>%
  #RunUMAPMetacells(reduction='harmony', dims=1:20)


seurat_res1.7_wgcna <- SetDatExpr(
  seurat_res1.7_wgcna,
  group_name = c("2"), # the name of the group of interest in the group.by column
  group.by='seurat_clusters', # the metadata column containing the cell type info. This same column should have also been used in MetacellsByGroups
  assay = 'RNA', # using RNA assay
  slot = 'data' # using normalized data
)

seurat_res1.7_wgcna <- TestSoftPowers(
  seurat_res1.7_wgcna,
  networkType = 'signed' # you can also use "unsigned" or "signed hybrid"
)

p<-wrap_plots(PlotSoftPowers(seurat_res1.7_wgcna), ncol=2)
ggsave(plot=p,filename=paste0(FIGURE_OUTPUTDIR,"/WGCNA/WGCNA soft power plot.tiff"),width=15,height=14,units="cm",dpi=300)

#The general guidance for WGCNA and hdWGCNA is to pick the lowest soft power threshold that has a Scale Free Topology Model Fit greater than or equal to 0.8, so in this case we would select our soft power threshold as 7.

power_table <- GetPowerTable(seurat_res1.7_wgcna)

# construct co-expression network:
seurat_res1.7_wgcna <- ConstructNetwork(
  seurat_res1.7_wgcna,
  tom_name = "12", # name of the topoligical overlap matrix written to disk
  overwrite_tom = TRUE
)

tiff(filename=paste0(FIGURE_OUTPUTDIR,"/WGCNA/WGCNA Dendrogram.tiff"),width=15,height=6,units="cm",res=600)
PlotDendrogram(seurat_res1.7_wgcna, main='2 hdWGCNA Dendrogram')
dev.off()


# compute all MEs in the full single-cell dataset
seurat_res1.7_wgcna <- ModuleEigengenes(
 seurat_res1.7_wgcna,
 group.by.vars="CellLine"
)

# harmonized module eigengenes:
hMEs <- GetMEs(seurat_res1.7_wgcna)

# compute eigengene-based connectivity (kME):
seurat_res1.7_wgcna <- ModuleConnectivity(
  seurat_res1.7_wgcna,
  group.by = 'seurat_clusters', group_name = c("2")
)

# rename the modules
seurat_res1.7_wgcna <- ResetModuleNames(
  seurat_res1.7_wgcna,
  new_name = "M"
)

p <- PlotKMEs(seurat_res1.7_wgcna, ncol=6)
ggsave(plot=p,filename=paste0(FIGURE_OUTPUTDIR,"/WGCNA/WGCNA KME plot.tiff"),width=35,height=30,units="cm",dpi=300)

# get the module assignment table:
modules <- GetModules(seurat_res1.7_wgcna)


# get hub genes
hub_df <- GetHubGenes(seurat_res1.7_wgcna, n_hubs = 10)
head(hub_df)


# compute gene scoring for the top 25 hub genes by kME for each module
# with UCell method
library(UCell)
seurat_res1.7_wgcna <- ModuleExprScore(
  seurat_res1.7_wgcna,
  n_genes = 25,
  method='UCell'
)
```

## Plots
```{r}
# make a featureplot of hMEs for each module
plot_list <- ModuleFeaturePlot(
  seurat_res1.7_wgcna,
  features='hMEs', # plot the hMEs
  order=TRUE, # order so the points with highest hMEs are on top
  reduction="umap_harmony"
)
p<-wrap_plots(plot_list, ncol=6)
ggsave(plot=p,filename=paste0(FIGURE_OUTPUTDIR,"/WGCNA/ModuleExpression FeaturePlot.tiff"),width=35,height=30,units="cm",dpi=300)

# plot with Seurat's DotPlot function
MEs <- GetMEs(seurat_res1.7_wgcna, harmonized=TRUE)
modules <- GetModules(seurat_res1.7_wgcna)
mods <- levels(modules$module); mods <- mods[mods != 'grey']
seurat_res1.7_wgcna@meta.data <- cbind(seurat_res1.7_wgcna@meta.data, MEs)
p <- DotPlot(seurat_res1.7_wgcna, features=mods, group.by = 'seurat_clusters')+
  RotatedAxis() +
  scale_color_gradient2(high='red', mid='grey95', low='blue')+
  theme_classic()+
  theme(axis.text.x=element_text(angle=90,vjust=0.5,hjust=1))
ggsave(plot=p,filename=paste0(FIGURE_OUTPUTDIR,"/WGCNA/Gene module average expression.tiff"),width=25,height=9,units="cm",dpi=300)

#Individual module network plots
ModuleNetworkPlot(
    seurat_res1.7_wgcna, 
    outdir='ModuleNetworks2', # new folder name
    n_inner = 20, # number of genes in inner ring
    n_outer = 30, # number of genes in outer ring
    n_conns = Inf, # show all of the connections
    plot_size=c(10,10), # larger plotting area
    vertex.label.cex=1 # font size
)

# hubgene network
seurat_res1.7_wgcna@misc[["res1.7"]][["wgcna_net"]][["TOMFiles"]]<-paste0(Sys.getenv("ONEDRIVE"),"\\Postdoc\\Project\\RNAseq\\SGCE scRNAseq\\2nd PT2NoAraC\\TOM\\12_TOM.rda")

tiff(filename=paste0(FIGURE_OUTPUTDIR,"/WGCNA/WGCNA HubGeneNetworkPlot.tiff"),width=35,height=30,units="cm",res=300)
HubGeneNetworkPlot(
  seurat_res1.7_wgcna,
  n_hubs = 3, n_other=5,
  edge_prop = 0.75,
  mods = 'all'
)
dev.off()


# Umap of genes
seurat_res1.7_wgcna <- RunModuleUMAP(
  seurat_res1.7_wgcna,
  n_hubs = 10, # number of hub genes to include for the UMAP embedding
  n_neighbors=15, # neighbors parameter for UMAP
  min_dist=0.1 # min distance between points in UMAP space
)

# get the hub gene UMAP table from the seurat object
umap_df <- GetModuleUMAP(seurat_res1.7_wgcna)

# plot with ggplot
ggplot(umap_df, aes(x=UMAP1, y=UMAP2)) +
  geom_point(
   color=umap_df$color, # color each point by WGCNA module
   size=umap_df$kME*2 # size of each point based on intramodular connectivity
  ) +
  umap_theme()
```


## Module Trait correlation
```{r}
seurat_res1.7_wgcna$Genotype <- as.factor(seurat_res1.7_wgcna$Genotype)
seurat_res1.7_wgcna$seurat_clusters <- as.factor(seurat_res1.7_wgcna$seurat_clusters)

cur_traits <- c('Genotype',"seurat_clusters",'percent.mt', 'S.Score', 'G2M.Score','nCount_RNA', 'nFeature_RNA')


seurat_res1.7_wgcna <- ModuleTraitCorrelation(
  seurat_res1.7_wgcna,
  traits = cur_traits
)

p<-PlotModuleTraitCorrelation(
  seurat_res1.7_wgcna,
  label = 'fdr',
  label_symbol = 'stars',
  text_size = 2,
  text_digits = 2,
  text_color = 'white',
  high_color = 'red',
  mid_color = 'black',
  low_color = 'purple',
  plot_max = 0.2,
  combine=TRUE
)

ggsave(plot=p,filename=paste0(FIGURE_OUTPUTDIR,"/WGCNA/Gene module correlation.tiff"),width=25,height=20,units="cm",dpi=300)
```



## DME analysis
### Corrected vs Mutant
```{r}
group1 <- seurat_res1.7_wgcna@meta.data %>% subset(seurat_clusters %in% c('2') & Genotype == "Corrected") %>% rownames
group2 <- seurat_res1.7_wgcna@meta.data %>% subset(seurat_clusters %in% c('2') & Genotype =="Mutant") %>% rownames

DMEs <- FindDMEs(
  seurat_res1.7_wgcna,
  barcodes1 = group1,
  barcodes2 = group2,
  test.use='wilcox',
  wgcna_name='res1.7'
)

write.xlsx(DMEs,file=paste0(ANALYSIS_OUTPUTDIR,"/WGCNA/WGCNA_2_DME.xlsx"))

tiff(filename=paste0(FIGURE_OUTPUTDIR,"/WGCNA/WGCNA DME volcano plot.tiff"),width=10,height=8,units="cm",res=300)
PlotDMEsVolcano(
  seurat_res1.7_wgcna,
  DMEs,
  wgcna_name = 'res1.7'
)
dev.off()


```


## Enrichment analysis
```{r}
modules <- GetModules(seurat_res1.7_wgcna)
write.xlsx(modules[,1:3],file=paste0(ANALYSIS_OUTPUTDIR,"/WGCNA/modules.xlsx"))

query_temp<-lapply(unique(modules$module),FUN=function(x){FUN_geneid(subset(modules,module==x)$gene_name)})

names(query_temp)<-unique(modules$module)

WGCNA_module_GO<-FUN_Geneset_Overlap(query=query_temp,universe=FUN_geneid(rownames(seurat_res1.7)),prefix="WGCNA_module_GO",OrgDb=org.Hs.eg.db,ont="All",keyType="SYMBOL",minGSSize=50,maxGSSize=500,nGO=10,pAdjustMethod="BH",pvalueCutoff=0.01,qvalueCutoff=0.05,pthreshold=0.05)

WGCNA_module_GO<-read.xlsx(paste0(ANALYSIS_OUTPUTDIR,"/Geneset Enrichment/WGCNA_module_GO.xlsx"))


WGCNA_module_GO_DME_reduced<-FUN_ReduceGO(go=subset(WGCNA_module_GO,Cluster%in%c("2-M3","2-M10","2-M12","2-M13","2-M18","2-M16","2-M25") & ONTOLOGY=="BP" & p.adjust<0.05))$reducedTerms %>%
  left_join(y=WGCNA_module_GO,by=c("go"="ID"))
  
WGCNA_module_GO_DME_reduced$EnrichmentScore<-((as.numeric(str_split(WGCNA_module_GO_DME_reduced$GeneRatio,fixed("/"),simplify=TRUE)[,1]))/(as.numeric(str_split(WGCNA_module_GO_DME_reduced$GeneRatio,fixed("/"),simplify=TRUE)[,2])))/((as.numeric(str_split(WGCNA_module_GO_DME_reduced$BgRatio,fixed("/"),simplify=TRUE)[,1]))/(as.numeric(str_split(WGCNA_module_GO_DME_reduced$BgRatio,fixed("/"),simplify=TRUE)[,2])))
  
WGCNA_module_GO_DME_reduced$Ordering<-sapply(1:nrow(WGCNA_module_GO_DME_reduced),FUN=function(i){sum(as.numeric(subset(WGCNA_module_GO_DME_reduced,parentTerm==WGCNA_module_GO_DME_reduced$parentTerm[i])$EnrichmentScore))/nrow(subset(WGCNA_module_GO_DME_reduced,parentTerm==WGCNA_module_GO_DME_reduced$parentTerm[i]))})



write.xlsx(WGCNA_module_GO_DME_reduced,paste0(ANALYSIS_OUTPUTDIR,"/Geneset Enrichment/WGCNA_module_GO_DME_reduced.xlsx"))

WGCNA_module_GO_DME_reduced<-read.xlsx(paste0(ANALYSIS_OUTPUTDIR,"/Geneset Enrichment/WGCNA_module_GO_DME_reduced.xlsx"))


p<-WGCNA_module_GO_DME_reduced %>%
  subset(Count>=10) %>%
  ggplot(aes(x=(EnrichmentScore),y=reorder(reorder(Description,EnrichmentScore),Ordering),fill=parent))+
  geom_bar(stat="identity")+
  labs(y="GO terms",x="Hypergeometric enrichment score")+
  facet_wrap(.~Cluster,scales="free_y",nrow=2)+
  #scale_fill_manual(values=colour_palette)+
  theme_classic()+
  theme(axis.text=element_text(size=7,colour="black"),
        axis.title=element_blank(),
        axis.line = element_line(linewidth=0.25),
        legend.position="none",
        panel.spacing = unit(0.05, "lines"))
ggsave(plot=p,filename=paste0(FIGURE_OUTPUTDIR,"/WGCNA/WGCNA_module_GO.tiff"),units="cm",width=40,height=30,dpi=300)

p<-WGCNA_module_GO_DME_reduced %>%
  subset(go==parent & Count>=10 & p.adjust<0.05) %>%
  ggplot(aes(x=(EnrichmentScore),y=reorder(Description,EnrichmentScore),fill=parent))+
  geom_bar(stat="identity")+
  labs(y="GO terms",x="Hypergeometric enrichment score")+
  facet_wrap(.~Cluster,scales="free_y",nrow=1)+
  scale_fill_manual(values=colour_palette)+
  theme_classic()+
  theme(axis.text=element_text(size=7,colour="black"),
        axis.line = element_line(linewidth=0.25),
        legend.position="none",
        strip.text=element_blank(),
        panel.spacing = unit(0.05, "lines"))
ggsave(plot=p,filename=paste0(FIGURE_OUTPUTDIR,"/WGCNA/WGCNA_module_GO_reduced.tiff"),units="cm",width=40,height=30,dpi=300)
```


## Module gene expression
```{r}
modules<-read.xlsx(paste0(ANALYSIS_OUTPUTDIR,"/WGCNA/modules.xlsx"))

# 2-M1 module

DME_gene_expression<-lapply(c("M3","M10","M12","M13","M18","M16","M25"),FUN=function(x){
  print(x)
  temp_data<-subset(modules,module==x)$gene_name
  temp<-FUN_candidate_expression_testing(markers=temp_data,prefix="Neuron",seurat=subset(seurat_res1.7,seurat_clusters%in%c("1","2")),ident.var="Genotype",ident.1="Corrected",ident.2="Mutant")
  temp$module<-x
  return(temp)
}) %>% rbindlist() %>% as.data.frame()

write.xlsx(DME_gene_expression,file=paste0(ANALYSIS_OUTPUTDIR,"/WGCNA/DME_gene_expression.xlsx"))


DME_gene_expression<-read.xlsx(paste0(ANALYSIS_OUTPUTDIR,"/WGCNA/DME_gene_expression.xlsx"))

# DEG upset
DEG_Neuron_PT2_disease_sig<-read.xlsx(paste0(ANALYSIS_OUTPUTDIR,"/DEG/DEG_Neuron_PT2_disease.xlsx")) %>% subset(p_val_adj<0.05)
DME_gene_expression_sig<-subset(DME_gene_expression,`p.adj_Neuron_Corrected-Mutant`<0.05)

query_temp<-c(lapply(unique(DEG_Neuron_PT2_disease_sig$cluster),FUN=function(x){FUN_geneid(subset(DEG_Neuron_PT2_disease_sig,cluster==x)$gene)}),lapply(unique(DME_gene_expression_sig$module),FUN=function(x){FUN_geneid(subset(DME_gene_expression_sig,module==x)$gene)}))
names(query_temp)<-c(unique(DEG_Neuron_PT2_disease_sig$cluster),unique(DME_gene_expression_sig$module))

query_temp<-data.frame(gene=c(DEG_Neuron_PT2_disease_sig$gene,DME_gene_expression_sig$gene),
                       cluster=c(DEG_Neuron_PT2_disease_sig$cluster,DME_gene_expression_sig$module))

cl<-makeCluster(detectCores()-1)
clusterExport(cl,c("query_temp"))
temp<-parLapply(cl,levels(factor(query_temp$cluster)),fun=function(x){
  temp.x<-data.frame(sapply(unique(query_temp$gene),FUN=function(y){y%in%subset(query_temp,cluster==x)$gene}))
  names(temp.x)<-x
  temp.x
})
stopCluster(cl)
temp<-list.cbind(temp)
var.list1<-names(temp)


p<-ComplexUpset::upset(data=temp,
                       intersect=var.list1,
                       name="Genesets",
                       width_ratio=0.1,
                       sort_sets=FALSE,
                       encode_sets=FALSE,
                       sort_intersections_by='degree',
                       guides='over',
                       set_sizes=FALSE,
                       matrix=(intersection_matrix(geom=geom_point(shape=19,size=1.5,fill=NA)))
                       )
ggsave(plot=p,filename=paste0(FIGURE_OUTPUTDIR,"/WGCNA/Upset_DEG_Neuron_Disease_sig vs WGCNA_DME_sig .tiff"),units="cm",width=10,height=10,dpi=300)


# Overlap
```


## WGCNA and SCENIC
```{r}
regulonAUC_geneset<-readRDS(file=paste0(PROJECT_DIR,"/SCENIC/int/2.6_regulons_asGeneSet.Rds"))

modules <- GetModules(seurat_res1.7_wgcna)

query_temp<-lapply(unique(modules$module),FUN=function(x){FUN_geneid(subset(modules,module==x)$gene_name)})
names(query_temp)<-unique(modules$module)

WGCNA_enrichment_SCENIC<-FUN_Geneset_Overlap_General(query=query_temp,reference=regulonAUC_geneset,universe=FUN_geneid(rownames(seurat_res1.7)),prefix="WGCNA enrichment in SCENIC",nGO=20,pAdjustMethod="BH",pvalueCutoff=0.01,qvalueCutoff=0.05,pthreshold=0.05)


WGCNA_enrichment_SCENIC<-read.xlsx(paste0(ANALYSIS_OUTPUTDIR,"/Geneset Enrichment/WGCNA enrichment in SCENIC_GO.xlsx"))

WGCNA_enrichment_SCENIC_DME<-lapply(c("M3","M10","M12","M13","M18"),FUN=function(x){
  temp_data<-subset(WGCNA_enrichment_SCENIC,Cluster==x)
  temp<-lapply(1:nrow(temp_data),FUN=function(i){
    temp<-data.frame(RegulonTarget=unlist(str_split(temp_data$geneID[i],fixed("/"))))
    temp$RegulonTF<-str_remove(temp_data$ID[i],"_extended")
    return(temp)
  })%>%rbindlist()%>%as.data.frame()
  temp$module<-x
  return(temp)
})%>%rbindlist()%>%as.data.frame()

fwrite(WGCNA_enrichment_SCENIC_DME,file=paste0(ANALYSIS_OUTPUTDIR,"/WGCNA/WGCNA_enrichment_SCENIC_DME.csv"))
```

## WGCNA+SCENIC_DEG
```{r}
# SCENIC for WGCNA 2-M1
WGCNA_enrichment_SCENIC_DME<-fread(paste0(ANALYSIS_OUTPUTDIR,"/WGCNA/WGCNA_enrichment_SCENIC_DME.csv"),data.table=FALSE)

# DEG
DEG_Neuron_PT2_disease_sig<-read.xlsx(paste0(ANALYSIS_OUTPUTDIR,"/DEG/DEG_Neuron_PT2_disease.xlsx")) %>% subset(p_val_adj<0.05 & cluster=="Corrected")

# WGCNA 2-M1
seurat_res1.7_wgcna@misc[["res1.7"]][["wgcna_net"]][["TOMFiles"]]<-paste0(Sys.getenv("ONEDRIVE"),"\\Postdoc\\Project\\RNAseq\\SGCE scRNAseq\\2nd PT2NoAraC\\TOM\\12_TOM.rda")

modules <- GetModules(seurat_res1.7_wgcna) %>% 
  subset(module != 'grey') %>% 
  mutate(module = droplevels(module))

c("M3","M10","M12","M13","M18")

# All genes
all_relevant_genes<-data.frame(Gene=unique(c(FUN_geneid(DEG_Neuron_PT2_disease_sig$gene),WGCNA_enrichment_SCENIC_DME$RegulonTarget,WGCNA_enrichment_SCENIC_DME$RegulonTF,FUN_geneid(subset(modules,module %in% c("M3","M10","M12","M13","M18"))$gene_name))))

all_relevant_genes <- all_relevant_genes %>%
  mutate(DEG = Gene %in% FUN_geneid(DEG_Neuron_PT2_disease_sig$gene),
         WGCNA = Gene %in% FUN_geneid(subset(modules,module %in% c("M3","M10","M12","M13","M18"))$gene_name),
         SCENIC_TF = Gene %in% WGCNA_enrichment_SCENIC_DME$RegulonTF,
         SCENIC_Target = Gene %in% WGCNA_enrichment_SCENIC_DME$RegulonTarget,
         WGCNA_SCENICTFregulated = Gene %in% subset(WGCNA_enrichment_SCENIC_DME,RegulonTF %in% FUN_geneid(subset(modules,module %in% c("M3","M10","M12","M13","M18"))$gene_name))$RegulonTarget)
all_relevant_genes<-left_join(x=all_relevant_genes,y=subset(modules,module %in% c("M3","M10","M12","M13","M18"),select=c(gene_name,module)) %>% mutate(gene_name=FUN_geneid(gene_name)),by=c("Gene"="gene_name"))


apply(all_relevant_genes[,-1],2,FUN=function(x){summary(factor(x))})

# Upset
p<-ComplexUpset::upset(data=all_relevant_genes,
                       intersect=names(all_relevant_genes)[!names(all_relevant_genes)%in%c("Gene","module")],
                       name="Genesets",
                       width_ratio=0.1,
                       sort_sets=FALSE,
                       encode_sets=FALSE,
                       sort_intersections_by='degree',
                       guides='over',
                       set_sizes=FALSE,
                       matrix=(intersection_matrix(geom=geom_point(shape=19,size=1.5,fill=NA)))
                       )
ggsave(plot=p,filename=paste0(FIGURE_OUTPUTDIR,"/WGCNA/Gene overlap of M1 DEG SCENICM1.tiff"),units="cm",width=13,height=8,dpi=300)

# grouping df

all_relevant_genes<-p[[1]][["data"]][1:8]
all_relevant_genes$intersections<-mapvalues(all_relevant_genes$intersection,from=levels(factor(all_relevant_genes$intersection)),to=paste0("G",summary(factor(all_relevant_genes$intersection))))
all_relevant_genes$intersections[all_relevant_genes$intersections%in%c("G2","G6","G28")]<-"G28"

fwrite(all_relevant_genes,file=paste0(ANALYSIS_OUTPUTDIR,"/WGCNA/DEG_WGCNA_SCENIC_gene list.csv"))

lapply(unique(all_relevant_genes$intersections),FUN=function(x){
  fwrite(subset(all_relevant_genes,intersections==x),file=paste0(ANALYSIS_OUTPUTDIR,"/WGCNA/DEG_WGCNA_SCENIC_gene list_",x,".csv"))
})
```

### Enrichment analysis
```{r}
query_temp<-lapply(unique(all_relevant_genes$intersections),FUN=function(x){(subset(all_relevant_genes,intersections==x)$Gene)})
names(query_temp)<-unique(all_relevant_genes$intersections)
DEG_WGCNA_SCENIC_GO<-FUN_Geneset_Overlap(query=query_temp,universe=FUN_geneid(rownames(seurat_res1.7)),prefix="DEG_WGCNA_SCENIC",OrgDb=org.Hs.eg.db,ont="All",keyType="SYMBOL",minGSSize=50,maxGSSize=500,nGO=20,pAdjustMethod="BH",pvalueCutoff=0.01,qvalueCutoff=0.05,pthreshold=1)
DEG_WGCNA_SCENIC_GO<-read.xlsx(paste0(ANALYSIS_OUTPUTDIR,"/Geneset Enrichment/DEG_WGCNA_SCENIC_GO.xlsx"))


DEG_WGCNA_SCENIC_GO_reduced<-FUN_ReduceGO(go=subset(DEG_WGCNA_SCENIC_GO,ONTOLOGY=="BP" & p.adjust<0.05))$reducedTerms 

DEG_WGCNA_SCENIC_GO_reduced<-left_join(x=subset(DEG_WGCNA_SCENIC_GO,ONTOLOGY=="BP" & p.adjust<0.05),y=DEG_WGCNA_SCENIC_GO_reduced,by=c("ID"="go"))

DEG_WGCNA_SCENIC_GO_reduced$EnrichmentScore<-((as.numeric(str_split(DEG_WGCNA_SCENIC_GO_reduced$GeneRatio,fixed("/"),simplify=TRUE)[,1]))/(as.numeric(str_split(DEG_WGCNA_SCENIC_GO_reduced$GeneRatio,fixed("/"),simplify=TRUE)[,2])))/((as.numeric(str_split(DEG_WGCNA_SCENIC_GO_reduced$BgRatio,fixed("/"),simplify=TRUE)[,1]))/(as.numeric(str_split(DEG_WGCNA_SCENIC_GO_reduced$BgRatio,fixed("/"),simplify=TRUE)[,2])))

DEG_WGCNA_SCENIC_GO_reduced$Ordering<-sapply(1:nrow(DEG_WGCNA_SCENIC_GO_reduced),FUN=function(i){sum(as.numeric(subset(DEG_WGCNA_SCENIC_GO_reduced,parentTerm==DEG_WGCNA_SCENIC_GO_reduced$parentTerm[i])$EnrichmentScore))/nrow(subset(DEG_WGCNA_SCENIC_GO_reduced,parentTerm==DEG_WGCNA_SCENIC_GO_reduced$parentTerm[i]))})

write.xlsx(DEG_WGCNA_SCENIC_GO_reduced,paste0(ANALYSIS_OUTPUTDIR,"/Geneset Enrichment/DEG_WGCNA_SCENIC_GO_reduced.xlsx"))

DEG_WGCNA_SCENIC_GO_reduced<-read.xlsx(paste0(ANALYSIS_OUTPUTDIR,"/Geneset Enrichment/DEG_WGCNA_SCENIC_GO_reduced.xlsx"))


p<-DEG_WGCNA_SCENIC_GO_reduced %>%
  subset(p.adjust<0.05) %>%
  ggplot(aes(x=(EnrichmentScore),y=reorder(reorder(Description,EnrichmentScore),Ordering),fill=parent))+
  geom_bar(stat="identity")+
  geom_vline(xintercept=-log10(0.05))+
  labs(y="GO terms",x="Hypergeometric enrichment score")+
  facet_wrap(.~Cluster,scales="free",nrow=3)+
  #scale_fill_manual(values=colour_palette)+
  theme_classic()+
  theme(axis.text.x=element_text(size=7,colour="black"),
        axis.text.y=element_text(size=5,colour="black"),
        axis.title=element_blank(),
        axis.line = element_line(linewidth=0.25),
        legend.position="none",
        panel.spacing = unit(0.05, "lines"))
ggsave(plot=p,filename=paste0(FIGURE_OUTPUTDIR,"/WGCNA/DEG_WGCNA_SCENIC_GO_reduced.tiff"),units="cm",width=40,height=30,dpi=300)

p<-DEG_WGCNA_SCENIC_GO_reduced %>%
  subset(Description==parentTerm & p.adjust<0.05) %>%
  ggplot(aes(x=(EnrichmentScore),y=reorder(Description,EnrichmentScore),fill=parent))+
  geom_bar(stat="identity")+
  labs(y="GO terms",x="Hypergeometric enrichment score")+
  facet_wrap(.~Cluster,scales="free_y",nrow=3)+
  #scale_fill_manual(values=colour_palette)+
  theme_classic()+
  theme(axis.text=element_text(size=7,colour="black"),
        axis.line = element_line(linewidth=0.25),
        legend.position="none",
        panel.spacing = unit(0.05, "lines"))
ggsave(plot=p,filename=paste0(FIGURE_OUTPUTDIR,"/DEG_WGCNA_SCENIC_GO_reduced.tiff"),units="cm",width=40,height=30,dpi=300)
```


### Biased enrichment
```{r}
DEG_WGCNA_SCENIC_GO_reduced<-read.xlsx(paste0(ANALYSIS_OUTPUTDIR,"/Geneset Enrichment/DEG_WGCNA_SCENIC_GO_reduced.xlsx"))

temp<-subset(DEG_WGCNA_SCENIC_GO_reduced,Cluster %in% c("G13","G25","G37","G36","G392","G937","G224") & p.adjust<0.05 & ONTOLOGY=="BP")

temp_manual<-fread(paste0(ANALYSIS_OUTPUTDIR,"/Geneset enrichment/DEG_WGCNA_SCENIC_gene list_GO_Reduced_Annotation.csv"),data.table=FALSE)

temp<-subset(DEG_WGCNA_SCENIC_GO_reduced,Cluster %in% c("G13","G25","G37","G36","G392","G937","G224") & p.adjust<0.05 & ONTOLOGY=="BP")
temp$ManualTerm<-mapvalues(temp$Description,from=temp_manual$Description,to=temp_manual$ManualTerm)

temp$Ordering<-sapply(1:nrow(temp),FUN=function(i){sum(as.numeric(subset(temp,ManualTerm==temp$ManualTerm[i])$EnrichmentScore))/nrow(subset(temp,ManualTerm==temp$ManualTerm[i]))})

p<-ggplot(data=temp,
          aes(x=reorder(Description,Ordering),y=EnrichmentScore))+
  geom_point(aes(colour=Cluster,group=Cluster),size=1.5)+
  geom_line(aes(colour=Cluster,group=Cluster),linewidth=1,linetype="dashed")+
  geom_bar(data=subset(temp,select=c(Description,ManualTerm,Ordering)),
           aes(x=reorder(Description,Ordering),y=0.5,fill=ManualTerm),stat="identity")+
  scale_colour_colorblind()+
  scale_fill_manual(values=colour_palette)+
  guides(colour=guide_legend(override.aes=list(linewidth=4)),fill="none")+
  facet_grid(.~str_wrap(ManualTerm,30),scales="free_x",space="free",switch="both")+
  theme_classic()+
  theme(axis.text.x=element_text(angle=90,vjust=0.5,hjust=1,size=8),
        legend.position="bottom")
ggsave(plot=p,filename=paste0(FIGURE_OUTPUTDIR,"/WGCNA/GO_line.tiff"),units="cm",width=22,height=17,dpi=300)
```


### GO terms and genes
```{r}
DEG_WGCNA_SCENIC_GO_reduced<-read.xlsx(paste0(ANALYSIS_OUTPUTDIR,"/Geneset Enrichment/DEG_WGCNA_SCENIC_GO_reduced.xlsx"))

temp<-subset(DEG_WGCNA_SCENIC_GO_reduced,Cluster %in% c("G13","G25","G37","G36","G392","G937","G224") & p.adjust<0.05 & ONTOLOGY=="BP")

temp_manual<-fread(paste0(ANALYSIS_OUTPUTDIR,"/Geneset enrichment/DEG_WGCNA_SCENIC_gene list_GO_Reduced_Annotation.csv"),data.table=FALSE)

temp<-subset(DEG_WGCNA_SCENIC_GO_reduced,Cluster %in% c("G13","G25","G37","G36","G392","G937","G224") & p.adjust<0.05 & ONTOLOGY=="BP")
temp$ManualTerm<-mapvalues(temp$Description,from=temp_manual$Description,to=temp_manual$ManualTerm)

temp$Ordering<-sapply(1:nrow(temp),FUN=function(i){sum(as.numeric(subset(temp,ManualTerm==temp$ManualTerm[i])$EnrichmentScore))/nrow(subset(temp,ManualTerm==temp$ManualTerm[i]))})


temp_gene_list<-lapply(unique(temp$Cluster)[1:3],FUN=function(x){
  temp<-subset(temp,Cluster==x)
  lapply(unique(temp$ManualTerm),FUN=function(y){
    output<-data.frame(Gene=unlist(str_split(subset(temp,ManualTerm==y)$geneID,fixed("/"),simplify=FALSE)))
    output$ManualTerm<-y
    output$Cluster<-x
    return(output)
  })%>%rbindlist()
})%>%rbindlist()%>%as.data.frame()

cl<-makeCluster(detectCores()-1)
clusterExport(cl,c("temp_gene_list"))
temp_gene_list<-c(
  parLapply(cl,levels(factor(temp_gene_list$Cluster)),fun=function(x){
    temp.x<-data.frame(sapply(unique(temp_gene_list$Gene),FUN=function(y){y%in%subset(temp_gene_list,Cluster==x)$Gene}))
    names(temp.x)<-x
    temp.x
  }),
  parLapply(cl,levels(factor(temp_gene_list$ManualTerm)),fun=function(x){
    temp.x<-data.frame(sapply(unique(temp_gene_list$Gene),FUN=function(y){y%in%subset(temp_gene_list,ManualTerm==x)$Gene}))
    names(temp.x)<-x
    temp.x
  }))
stopCluster(cl)
temp_gene_list<-list.cbind(temp_gene_list)
var.list1<-names(temp_gene_list)


p<-ComplexUpset::upset(data=temp_gene_list,
                       mode="inclusive_intersection",
                       intersect=var.list1,
                       name="Genesets",
                       sort_sets=FALSE,
                       encode_sets=FALSE,
                       set_sizes=FALSE,
                       max_degree=2,
                       sort_intersections='descending',
                       guides='over',
                       matrix=(intersection_matrix(geom=geom_point(shape=19,size=1.5,fill=NA)))
)
ggsave(plot=p,filename=paste0(FIGURE_OUTPUTDIR,"/WGCNA/Upset_WGCNA-SCENIC-DEG_GO .tiff"),units="cm",width=15,height=12,dpi=300)

```



## Network construction
```{r}
library(igraph)
library(ggraph)

all_relevant_genes<-fread(file=paste0(ANALYSIS_OUTPUTDIR,"/WGCNA/DEG_WGCNA_SCENIC_gene list.csv"))

seurat_res1.7_wgcna@misc[["res1.7"]][["wgcna_net"]][["TOMFiles"]]<-paste0(Sys.getenv("ONEDRIVE"),"\\Postdoc\\Project\\RNAseq\\SGCE scRNAseq\\2nd PT2NoAraC\\TOM\\12_TOM.rda")

# get modules and TOM from the seurat obj
modules <- GetModules(seurat_res1.7_wgcna) %>% 
  subset(module != 'grey') %>% 
  mutate(module = droplevels(module))

# subset the TOM 
cur_TOM <- GetTOM(seurat_res1.7_wgcna)
cur_TOM[upper.tri(cur_TOM)] <- NA

# cast the network from wide to long format
cur_network <- cur_TOM %>% 
  reshape2::melt() %>% 
  dplyr::rename(gene1 = Var1, gene2 = Var2, weight=value) %>%
  subset(!is.na(weight)) %>%
  setNames(c("gene1","gene2","weight"))

# keep this network before subsetting
cur_network_full <- cur_network 

cur_network_full$gene1<-str_remove(cur_network_full$gene1,"-ENSG\\d{11}")
cur_network_full$gene2<-str_remove(cur_network_full$gene2,"-ENSG\\d{11}")

cur_network_full<-left_join(cur_network_full,subset(all_relevant_genes,select=c(Gene,module,intersections)),by=c("gene1"="Gene")) %>%
  left_join(subset(all_relevant_genes,select=c(Gene,module,intersections)),by=c("gene2"="Gene"))


# All genes in 2-M1
cur_network1 <- cur_network_full %>% 
  subset(gene1 %in% all_relevant_genes$Gene & gene2 %in% all_relevant_genes$Gene & weight>0)



# Summary all_relevant_genes

cur_network1_summary<-cur_network1 %>%
  group_by(gene1) %>%
  summarise(TotalWeight=sum(weight))

all_relevant_genes<-left_join(all_relevant_genes,cur_network1_summary,by=c("Gene"="gene1"))
cur_network1<-left_join(cur_network1,cur_network1_summary,by="gene1")

fwrite(cur_network1,file=paste0(ANALYSIS_OUTPUTDIR,"/WGCNA/DEG_WGCNA_SCENIC_weighed interaction.csv"))
fwrite(all_relevant_genes,file=paste0(ANALYSIS_OUTPUTDIR,"/WGCNA/DEG_WGCNA_SCENIC_gene list.csv"))
fwrite(cur_network_full,file=paste0(ANALYSIS_OUTPUTDIR,"/WGCNA/Complete WGCNA network.csv"))


```

### Network analysis
#### Gene group parameters
```{r}
all_relevant_genes<-fread(file=paste0(ANALYSIS_OUTPUTDIR,"/WGCNA/DEG_WGCNA_SCENIC_gene list.csv"))
cur_network1<-fread(file=paste0(ANALYSIS_OUTPUTDIR,"/WGCNA/DEG_WGCNA_SCENIC_weighed interaction.csv"))

intersection_network<-cur_network_full %>% 
  subset(gene1 %in% subset(all_relevant_genes,intersections %in% unique(all_relevant_genes$intersections))$Gene & gene2 %in% subset(all_relevant_genes,intersections %in% unique(all_relevant_genes$intersections))$Gene & weight>0) %>%
  group_by(intersections.x,intersections.y) %>%
  summarise(MeanWeight=mean(weight),
            MeanNumberIntersection=n()/length(unique(gene1)))

fwrite(intersection_network,file=paste0(ANALYSIS_OUTPUTDIR,"/WGCNA/DEG_WGCNA_SCENIC_intersection_network.csv"))

intersection_network_node_summary<-intersection_network %>%
  group_by(intersections.x) %>%
  subset(intersections.x==intersections.y) %>%
  summarise(IntraWeight=mean(MeanWeight),
            IntraNumberIntersection=mean(MeanNumberIntersection)) %>%
  full_join(y=intersection_network %>%
               group_by(intersections.x) %>%
               subset(intersections.x!=intersections.y) %>%  
               summarise(InterWeight=mean(MeanWeight),
                         InterNumberIntersection=mean(MeanNumberIntersection)),
             by="intersections.x") %>%
  data.frame()
intersection_network_node_summary[is.na(intersection_network_node_summary)]<-0
names(intersection_network_node_summary)[1]<-"group"


p<-intersection_network_node_summary%>%
  melt(id.vars="group") %>%
  mutate(group=factor(group,levels=c("G1","G13","G25","G28","G36","G37","G224","G372","G392","G937"))) %>%
  ggplot(aes(x=group,y=value,fill=group))+
  geom_bar(stat="identity")+
  facet_wrap(.~variable,scales="free")+
  scale_fill_tableau()+
  theme_classic()+
  theme(axis.text.x=element_blank())
ggsave(plot=p,filename=paste0(FIGURE_OUTPUTDIR,"/WGCNA/DEG_WGCNA_SCENIC_group_network parameters.tiff"),units="cm",width=12,height=8,dpi=300)


```


#### Gene parameters in the context of gene groups
```{r}
all_relevant_genes<-fread(file=paste0(ANALYSIS_OUTPUTDIR,"/WGCNA/DEG_WGCNA_SCENIC_gene list.csv"))
cur_network1<-fread(file=paste0(ANALYSIS_OUTPUTDIR,"/WGCNA/DEG_WGCNA_SCENIC_weighed interaction.csv"))
#cur_network_full<-fread(file=paste0(ANALYSIS_OUTPUTDIR,"/WGCNA/Complete WGCNA network.csv"))

cl<-makeCluster(20)
clusterExport(cl, c("all_relevant_genes","cur_network1"),envir=environment())
all_relevant_genes<-parLapply(cl,unique(all_relevant_genes$Gene),fun=function(x){
  temp<-subset(all_relevant_genes,Gene==x)
  temp1<-subset(cur_network1,(gene1==temp$Gene & intersections.y==temp$intersections)|(gene2==temp$Gene & intersections.x==temp$intersections))
  temp2<-subset(cur_network1,(gene1==temp$Gene & intersections.y!=temp$intersections)|(gene2==temp$Gene & intersections.x!=temp$intersections))
  temp$Intragroup_MeanWeight<-mean(temp1$weight)
  temp$Intergroup_MeanWeight<-mean(temp2$weight)
  return(temp)
}) %>% rbindlist() %>% as.data.frame()
stopCluster(cl)
fwrite(all_relevant_genes,file=paste0(ANALYSIS_OUTPUTDIR,"/WGCNA/DEG_WGCNA_SCENIC_gene list.csv"))
```



#### Key TFs for group G37
```{r}
all_relevant_genes<-fread(file=paste0(ANALYSIS_OUTPUTDIR,"/WGCNA/DEG_WGCNA_SCENIC_gene list.csv"))
cur_network1<-fread(file=paste0(ANALYSIS_OUTPUTDIR,"/WGCNA/DEG_WGCNA_SCENIC_weighed interaction.csv"))

network_temp <- read_csv("2nd PT2NoAraC/WGCNA/Merged Network default edge (210N523E).csv")
network_temp<-network_temp[,c(2,3)]
network_temp<-subset(network_temp,interaction=="regulon")
network_temp$TF<-str_split(network_temp$name,fixed(" (regulon) "),simplify=TRUE)[,1]
network_temp$Target<-str_split(network_temp$name,fixed(" (regulon) "),simplify=TRUE)[,2]
network_temp<-left_join(network_temp,subset(all_relevant_genes,select=c("Gene","intersections")),by=c("Target"="Gene"))

network_temp_TF<-lapply(network_temp$TF,FUN=function(x){
  temp<-data.frame(TF=x)
  temp$G25Total<-nrow(subset(network_temp,TF==x & intersections=="G25"))
  temp$G37Total<-nrow(subset(network_temp,TF==x & intersections=="G37"))
  temp$G28Total<-nrow(subset(network_temp,TF==x & intersections=="G28"))
  return(temp)
})%>%rbindlist()%>%data.frame()%>%unique()
```



### Integrate with PPI network
```{r}
load(paste0(Sys.getenv("ONEDRIVE"),"\\PhD\\!!!! Projects\\Bioinformatic\\PPI\\PPI_database.RData"))

all_relevant_genes<-fread(file=paste0(ANALYSIS_OUTPUTDIR,"/WGCNA/DEG_WGCNA_SCENIC_gene list.csv"))
cur_network1<-fread(file=paste0(ANALYSIS_OUTPUTDIR,"/WGCNA/DEG_WGCNA_SCENIC_weighed interaction.csv"))
#cur_network_full<-fread(file=paste0(ANALYSIS_OUTPUTDIR,"/WGCNA/Complete WGCNA network.csv"))

ppi_network1<-merged_database_unique_pair %>% 
  subset(hgnc_symbol_A %in% all_relevant_genes$Gene & hgnc_symbol_B %in% all_relevant_genes$Gene) %>%
  left_join(y=subset(all_relevant_genes,select=c(Gene,module,intersections)),by=c("hgnc_symbol_A"="Gene")) %>%
  left_join(y=subset(all_relevant_genes,select=c(Gene,module,intersections)),by=c("hgnc_symbol_B"="Gene"))
  
fwrite(ppi_network1,file=paste0(ANALYSIS_OUTPUTDIR,"/WGCNA/DEG_WGCNA_SCENIC_PPI interaction.csv"))
```


# MAGMA

```{r}
all_relevant_genes<-fread(file=paste0(ANALYSIS_OUTPUTDIR,"/WGCNA/DEG_WGCNA_SCENIC_gene list.csv"))

load(file=paste0(SAVE_DIR,"/seurat_res1.7.RData"))

query_temp<-lapply(unique(all_relevant_genes$intersections),FUN=function(x){subset(all_relevant_genes,intersections==x)$Gene})
names(query_temp)<-unique(all_relevant_genes$intersections)

PD_gene_list<-fread(paste0(PROJECT_DIR,"/Parkinson Disease and Complex Parkinsonism (1).txt"),data.table=FALSE)
gene_list_name<-names(PD_gene_list)
PD_gene_list<-lapply(1:ncol(PD_gene_list),FUN=function(i){PD_gene_list[PD_gene_list[,i]!="",i]})
names(PD_gene_list)<-gene_list_name


all_relevant_genes_disease_enrichment<-FUN_Geneset_Overlap_General(query=query_temp,reference=PD_gene_list,universe=FUN_geneid(rownames(seurat_res1.7)),prefix="WGCNA gene group in disease",nGO=20,pAdjustMethod="BH",pvalueCutoff=0.01,qvalueCutoff=0.05,pthreshold=0.05)



```


# For presentation
## Expression plot for presentation
```{r}
temp_gene_list<-data.frame(
  gene=c("SGCA","SGCB","SGCD","SGCE","SGCG",
         "DCX","RBFOX3","SNAP25","STMN2","SYT1",
         "GAD1","GAD2","CALB2","NPY","SST","RELN","SLC32A1",
         "MKI67","ASCL1","FABP7","RFX4","TTYH1",
         "FOXG1","NKX2-1","LHX6","ERBB4","ARX","MAFB","SOX6",
         "ZIC1","GBX2","LHX8","GBX1","LMO3","NDN","ENC1",
         "FOXP1","FOXP2","MEIS2","ISL1","EBF1","PPP1R1B",
         "NR2F1","NR2F2","PAX6","FOXA2","SLC17A6","SLC17A7","CHAT"),
  group=c(rep("SGCs",5),rep("Neuron",5),rep("GABAergic",7),rep("Progenitor",5),rep("MGE1",7),rep("MGE3","7"),rep("MGE2/LGE",6),rep("Others",7))
)


p<-VlnPlot(seurat_res1.7,features=FUN_gene(temp_gene_list$gene),stack=TRUE,fill.by="ident",flip=TRUE)$data %>%
  mutate(feature=str_split(feature,"-E",simplify=TRUE)[,1],
         group=mapvalues(feature,from=temp_gene_list$gene,to=temp_gene_list$group)) %>%
  ggplot(aes(x=feature,y=expression,fill=ident))+
  geom_violin(scale="width",linewidth=0.1)+
  facet_wrap(group~.,scales="free_x")+
  scale_fill_tableau()+
  theme_classic()+
  theme(legend.position="none",
        axis.text.x=element_text(size=6))
ggsave(plot=p,filename=paste0(FIGURE_OUTPUTDIR,"/Presentation/Violin plot for expression.tiff"),height=9,width=16,units="cm",dpi=300,device="tiff",limitsize = FALSE)


# SGCs expression
p<-VlnPlot(seurat_res1.7,features=FUN_gene(temp_gene_list$gene),group.by="seurat_clusters",split.by="Genotype",stack=TRUE,fill.by="ident",flip=TRUE)$data %>%
  mutate(feature=str_split(feature,"-E",simplify=TRUE)[,1],
         group=mapvalues(feature,from=temp_gene_list$gene,to=temp_gene_list$group)) %>%
  subset(group=="SGCs") %>%
  ggplot(aes(x=ident,y=expression,fill=split))+
  geom_violin(scale="width",linewidth=0.1)+
  facet_wrap(.~feature)+
  scale_fill_tableau()+
  theme_classic()+
  theme(legend.position="none",
        axis.text.x=element_text(size=6))
ggsave(plot=p,filename=paste0(FIGURE_OUTPUTDIR,"/Presentation/Violin plot for SGC expression.tiff"),height=9,width=16,units="cm",dpi=300,device="tiff",limitsize = FALSE)
```


## UMAP
```{r}
p<-DimPlot(seurat_res1.7,label=TRUE,reduction="umap_harmony")+
  scale_colour_tableau()+
  theme(axis.text=element_blank(),
        axis.title=element_blank(),
        axis.line=element_blank(),
        axis.ticks=element_blank())
ggsave(plot=p,filename=paste0(FIGURE_OUTPUTDIR,"/Presentation/UMAP.tiff"),height=4,width=6,units="cm",dpi=300,device="tiff",limitsize = FALSE)


p<-DimPlot(seurat_res1.7,label=TRUE,reduction="umap_harmony")+
  scale_colour_tableau()
ggsave(plot=p,filename=paste0(FIGURE_OUTPUTDIR,"/Presentation/UMAP2.tiff"),height=8,width=10,units="cm",dpi=300,device="tiff",limitsize = FALSE)
```

## GO
```{r}
DEG_disease_GO_reduced<-read.xlsx(paste0(ANALYSIS_OUTPUTDIR,"/Geneset Enrichment/DEG_Neuron_PT2_disease_GO_reduced.xlsx"))

p<-DEG_disease_GO_reduced %>%
  subset(ID==parent & ONTOLOGY=="BP" & p.adjust<0.05) %>%
  ggplot(aes(x=(EnrichmentScore),y=reorder(Description,EnrichmentScore),fill=parent))+
  geom_bar(stat="identity")+
  labs(y="GO terms",x="Hypergeometric enrichment score")+
  facet_wrap(.~Cluster,scales="free_y",nrow=1)+
  scale_fill_manual(values=colour_palette)+
  theme_classic()+
  theme(axis.text=element_text(size=10,colour="black"),
        axis.line = element_line(linewidth=0.25),
        legend.position="none",
        panel.spacing = unit(0.05, "lines"))
ggsave(plot=p,filename=paste0(FIGURE_OUTPUTDIR,"/Presentation/DEG_disease_GO_reduced.tiff"),units="cm",width=20,height=11.25,dpi=300)


WGCNA_module_GO_DME_reduced<-read.xlsx(paste0(ANALYSIS_OUTPUTDIR,"/Geneset Enrichment/WGCNA_module_GO_DME_reduced.xlsx"))
p<-WGCNA_module_GO_DME_reduced %>%
  subset(ID==parent & Count>=10 & Cluster=="2-M1" & p.adjust<0.05) %>%
  ggplot(aes(x=(EnrichmentScore),y=reorder(Description,EnrichmentScore),fill=parent))+
  geom_bar(stat="identity")+
  labs(y="GO terms",x="Hypergeometric enrichment score")+
  facet_wrap(.~Cluster,scales="free_y",nrow=1)+
  scale_fill_manual(values=colour_palette)+
  theme_classic()+
  theme(axis.text=element_text(size=10,colour="black"),
        axis.line = element_line(linewidth=0.25),
        legend.position="none",
        strip.text=element_blank(),
        panel.spacing = unit(0.05, "lines"))
ggsave(plot=p,filename=paste0(FIGURE_OUTPUTDIR,"/Presentation/WGCNA_module_GO_reduced.tiff"),units="cm",width=13,height=13,dpi=300)
```


## Pseudotime
```{r}
p<-seurat_allison_res1.7@meta.data %>%
  subset(Batch %in% c("This")) %>%
  ggplot(aes(x=seurat_clusters_original,y=monocle_pseudotime,colour=Genotype),fill=NA)+
  geom_violin(scale="width")+
  geom_point(position=position_jitterdodge(),stroke=0.25,shape=21,size=0.5)+
  scale_colour_tableau()+
  theme_classic()+
  theme(legend.position="bottom")
ggsave(plot=p,filename=paste0(FIGURE_OUTPUTDIR,"/Presentation/Pseudotime_disease comparison.tiff"),units="cm",width=11,height=7,dpi=300)
```


# Transcript
```{r}
TranscriptCount <- readRDS("C:/Users/lizon/OneDrive - Cardiff University/Postdoc/Project/RNAseq/SGCE scRNAseq/Transcript/TranscriptCount.RDS")

rownames(TranscriptCount)<-make.unique(rownames(TranscriptCount))
colnames(TranscriptCount)<-paste(str_split(colnames(TranscriptCount),"_",simplify=TRUE)[,1],str_split(colnames(TranscriptCount),"_",simplify=TRUE)[,4],sep="_")

seurat_transcription<-CreateSeuratObject(counts=as.matrix(TranscriptCount[rownames(TranscriptCount),colnames(TranscriptCount) %in% colnames(seurat_res1.7)]),
                           project="SGCE_transcript",
                           meta.data=seurat_res1.7@meta.data,
                           min.cells = 3, min.features = 200)


seurat_transcript<-seurat_transcription[rowSums(seurat_transcription@assays$RNA@layers$counts)>5,]

seurat_transcript<-NormalizeData(seurat_transcript)
seurat_transcript<-FindVariableFeatures(seurat_transcript) %>% ScaleData(vars.to.regress=c("percent.mt","nCount_RNA"))
p<-VlnPlot(seurat_transcript,features=grep("SGCE",rownames(seurat_transcript),value=T),group.by="seurat_clusters",split.by="Genotype",stack=TRUE)+theme(legend.position="none",panel.background=element_rect(fill="white"),plot.background=element_rect(fill="white"))
ggsave(plot=p,filename=paste0(FIGURE_OUTPUTDIR,"/SGCE transcript expression.tiff"),units="cm",width=40,height=20,dpi=150)
```


## SGCE sequence
```{r}
temp<-data.frame(File=list.files(path=paste0(ANALYSIS_OUTPUTDIR,"/SGCE sequence"),pattern="exon.dna"))
temp$Transcript<-str_split(temp$File," ",simplify=T)[,1]
temp$Exon<-str_split(temp$File," ",simplify=T)[,2]

temp<-temp %>%
  group_by(Transcript,Exon) %>%
  summarise(N=n()) %>%
  dcast(Transcript~Exon,value.var="N") %>%
  subset(Transcript %in% paste(str_split(grep("SGCE",rownames(seurat_transcript),value=T),"-",simplify=T)[,2],str_split(grep("SGCE",rownames(seurat_transcript),value=T),"-",simplify=T)[,3],sep="-"))

write.xlsx(temp,paste0(ANALYSIS_OUTPUTDIR,"/exon usage.xlsx"))



```


# save
```{r}
#save.image(file=paste0(SAVE_DIR,"/",Sys.Date(),".RData"))

save(seurat,file=paste0(SAVE_DIR,"/","seurat.RData"))
save(seurat_coding,file=paste0(SAVE_DIR,"/","seurat_coding.RData"))
save(seurat_neuron,file=paste0(SAVE_DIR,"/","seurat_neuron.RData"))
save(seurat_astrocyte,file=paste0(SAVE_DIR,"/","seurat_astrocyte.RData"))
save(seurat_transcript,file=paste0(SAVE_DIR,"/","seurat_transcript.RData"))

save(seurat_neuron_filtered,file=paste0(SAVE_DIR,"/","seurat_neuron_filtered.RData"))
save(feature_ncell,file=paste0(SAVE_DIR,"/feature_ncell.RData"))
save(seurat_normalised,file=paste0(SAVE_DIR,"/","seurat_normalised.RData"))
save(seurat_normalised_cluster_list,file=paste0(SAVE_DIR,"/","seurat_normalised_cluster_list.RData"))
save(seurat_res1.7,file=paste0(SAVE_DIR,"/","seurat_res1.7.RData"))
save(seurat_res1.7_AUC,file=paste0(SAVE_DIR,"/","seurat_res1.7_AUC.RData"))
save(seurat_res1.7_AUC_subset,file=paste0(SAVE_DIR,"/","seurat_res1.7_AUC_subset.RData"))

save(monocle_res1.7,file=paste0(SAVE_DIR,"/","monocle_allison_res1.7.RData.RData"))
save(list=c("pr_test_res","pr_deg_ids","monocle_processed"),file=paste0(SAVE_DIR,"/","monocle_allison_res1.7_pseudotime_DEG.RData"))

save(seurat_allison_res1.7,file=paste0(SAVE_DIR,"/","seurat_allison_res1.7.RData"))

save(seurat_res1.7_wgcna,file=paste0(SAVE_DIR,"/","seurat_res1.7_wgcna.RData"))
```